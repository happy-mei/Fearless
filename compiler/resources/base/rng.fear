package base.rng
alias base.Block as Block,
alias base.UInt as UInt, alias base.Float as Float,
alias base.F as F,
alias base.FInfo as FInfo,
alias base.Sealed as Sealed,
alias base.Ref as Ref, alias base.RefImm as RefImm,

/// https://en.wikipedia.org/wiki/Linear_congruential_generator,
/// parameters from musl (https://git.musl-libc.org/cgit/musl/tree/src/prng/rand.c)
/// We actually only take the highest half of the bits because the low order bits have poor randomness
FRandom: F[UInt, mut Random]{seed -> Block#
  .if {seed == 0u} .error {FInfo.msg "Seed may not be zero"}
  .let prev = {Ref.ofImm(seed)}
  .return {{
    .uint -> Block#
      .do {prev := ((prev.get) * 6364136223846793005u + 1u >> 33u)}
      .return {prev.get},
    }}
  }
Random: {
  /// Generate a random number between zero and 2147483647 (2^32)
  mut .uint: UInt,
  /// Generate a random float in the range. This is a simple approach, and may have some bias. A more
  /// accurate approach with a rejection loop may be used in the future.
  mut .uint(minInclusive: UInt, maxExclusive: UInt): UInt -> Block#
     .assert({minInclusive <= maxExclusive}, "Cannot generate a random number, "+(minInclusive.str)+" is greater than "+(maxExclusive.str))
     .return {(this.float * (maxExclusive.float - (minInclusive.float)) + (minInclusive.float)).floor.uint},

  /// Generate a random number between zero and one (inclusive)
  mut .float: Float -> this.uint.float / 2147483647.0,
  }
