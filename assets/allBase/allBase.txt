
//---File assertions.fear
package base

Assert:Sealed{
  !(assertion: Bool): Void -> this!(assertion, { Void }),
  ![R](assertion: Bool, cont: mut AssertCont[R]): R -> assertion ? {
    .then -> cont#,
    .else -> this._fail
    },
  ![R](assertion: Bool, msg: Str, cont: mut AssertCont[R]): R -> assertion ? {
      .then -> cont#,
      .else -> this._fail(msg)
      },
  ._fail[R]: R -> Magic!,
  ._fail[R](msg: Str): R -> Magic!,
  }
AssertCont[R]:{ mut #: R }

//---File blocks.fear
package base

ReturnStmt[R]:{ mut #: R }
Condition:{ mut #: Bool }
VarContinuation[X,R]:{ mut #(x: X, self: mut Block[R]): R }
Block:{
  #[R]: mut Block[R] -> {},
  #[X:read,mut,imm,iso](x: X): Void -> this#(x, Void),
  #[X:read,mut,imm,iso, R:read,mut,imm,iso](_: X, res: R): R -> res,
  #[X1:read,mut,imm,iso, X2:read,mut,imm,iso, R:read,mut,imm,iso](_: X1, _: X2, res: R): R -> res,
  #[X1:read,mut,imm,iso, X2:read,mut,imm,iso, X3:read,mut,imm,iso, R:read,mut,imm,iso](_: X1, _: X2, _: X3, res: R): R -> res,
  #[X1:read,mut,imm,iso, X2:read,mut,imm,iso, X3:read,mut,imm,iso, X4:read,mut,imm,iso, R:read,mut,imm,iso](_: X1, _: X2, _: X3, _: X4, res: R): R -> res,
  }
Block[R]:{
  mut .return(a: mut ReturnStmt[R]): R -> a#,
  mut .do(r: mut ReturnStmt[Void]): mut Block[R] -> this._do(r#),
    mut ._do(v: Void): mut Block[R] -> this,
  mut .assert(p: mut Condition): mut Block[R] -> Assert!(p#, mut AssertCont[mut Block[R]]{this}),
  mut .assert(p: mut Condition, failMsg: Str): mut Block[R] ->
    Assert!(p#, failMsg, mut AssertCont[mut Block[R]]{this}),
  mut .let[X](x: mut ReturnStmt[X], cont: mut VarContinuation[X, R]): R -> cont#(x#, this),
  mut .letIso[X:iso](x: X, cont: mut VarContinuation[mut X, R]): R -> cont#(x, this),
  mut .if(p: mut Condition): mut BlockIf[R] -> p# ? { 'cond
    .then -> { 't
      .return(a) -> _DecidedBlock#(a#),
      .error(info) -> Error!(info#),
      .do(r) -> t._do[](r#),
        mut ._do(v: Void): mut Block[R] -> this,
      },
    .else -> { 'f
      .return(_) -> this,
      .do(_) -> this,
      .error(_) -> this,
      },
    },
  }
BlockIf[R]:{
  mut .return(a: mut ReturnStmt[R]): mut Block[R],
  mut .do(r: mut ReturnStmt[Void]): mut Block[R],
  mut .error(info: mut ReturnStmt[Info]): mut Block[R],
  }
_DecidedBlock:{
  #[R](res: R): mut Block[R] -> { 'self
    .return(_) -> res,
    .do(_) -> self,
    .var(_, _) -> res,
    }
  }

//---File bools.fear
package base
Bool:Sealed,Stringable,ToImm[Bool]{
  .and(b: Bool): Bool,
  &&(b: Bool): Bool -> this.and(b),
  .or(b: Bool): Bool,
  ||(b: Bool): Bool -> this.or(b),
  .not: Bool,
  .if[R:read,mut,imm,iso](f: mut ThenElse[R]): R,
  ?[R:read,mut,imm,iso](f: mut ThenElse[R]): R -> this.if(f),
  }
True:Bool{ .and(b) -> b, .or(b) -> this, .not -> False, .if(f) -> f.then(), .str -> "True", .toImm -> True }
False:Bool{ .and(b) -> this, .or(b) -> b, .not -> True, .if(f) -> f.else(), .str -> "False", .toImm -> False }
ThenElse[R:read,mut,imm,iso]:{ mut .then: R, mut .else: R, }

//---File caps\capabilities.fear
package base.caps

System:Sealed{
  mut .clone: iso System -> { _System },
  ._preventCreation: _System,
  }
_System:Sealed,System{ _System }

//---File caps\env.fear
package base.caps

Env:{
  mut .launchArgs: base.LList[Str],
  }

FEnv:F[mut System, mut Env],Sealed{
  #(s) -> {
    .launchArgs -> Magic!
    },
  .io(io: mut IO): mut Env -> {
    .launchArgs -> Magic!
    }
  }

//---File caps\io.fear
package base.caps
alias base.LList[base.Str] as Path,

IO:{
  mut .print(msg: Str): Void,
  mut .println(msg: Str): Void,
  mut .printErr(msg: Str): Void,
  mut .printlnErr(msg: Str): Void,
  }
FIO:F[mut System, mut IO],Sealed{
  s -> {
    .print(msg) -> Magic!,
    .println(msg) -> Magic!,
    .printErr(msg) -> Magic!,
    .printlnErr(msg) -> Magic!,
    }
  }

FileHandleMode:Stringable,Sealed{}
Read:FileHandleMode{ "r" }
Write:FileHandleMode{ "r+" }
Create:FileHandleMode{ "w+" }

//---File caps\isopod.fear
package base.caps

IsoPod:{ #[T:imm,iso](val: iso T): mut IsoPod[iso T] -> base.Magic! }
IsoPod[T:imm,iso]:{
  readOnly .isAlive: Bool -> Magic!,
  readOnly .isDead: Bool -> this.isAlive.not,
  readOnly .peek[R](f: mut IsoViewer[T, R]): R -> Magic!,
  mut !: iso T -> Magic!,
  mut .consume[R](f: mut IsoConsumer[T, R]): R -> this.isAlive ? { .then -> f.some(this!), .else -> f.empty },
  mut .next(val: iso T): Void -> Magic!,
  mut :=(val: iso T): Void -> this.next(val),
  mut .mutate(f: F[mut T, Void]): Bool -> this.consume{
    .some(x) -> Block#(this.next(_IsoMutator#(f, x)), True),
    .empty -> False,
    }
  }
IsoConsumer[T:imm,iso, R]:{
  mut .some(x: iso T): R,
  mut .empty: R,
  }
IsoViewer[T:imm,iso, R]:{
  mut .some(x: readOnly T): R,
  mut .empty: R,
  }
_IsoMutator:{ #[T,R](f: F[mut T, R], val: mut T): mut T -> Block#(f#val, val) }


//---File caps\pkg.fear
package base.caps
alias base.Abort as Abort,
alias base.Magic as Magic,
alias base.Void as Void,
alias base.F as F,
alias base.Sealed as Sealed,
alias base.Str as Str,
alias base.Let as Let,
alias base.Stringable as Stringable,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Block as Block,

//---File comparisons.fear
package base

Ordering: {
  .match[R](m: mut OrderingMatch[R]): R,
  }
FOrdering: {
  .less: Ordering -> {m -> m.less},
  .equal: Ordering -> {m -> m.equal},
  .greater: Ordering -> {m -> m.greater},
  }
OrderingMatch[R]: {
  mut .less: R,
  mut .equal: R,
  mut .greater: R,
  }

CompareInts: F[Int, Int, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }
CompareUInts: F[UInt, UInt, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }
CompareFloats: F[Float, Float, Ordering]{
  a, b -> Block#
    .if {a > b} .return {FOrdering.greater}
    .if {a < b} .return {FOrdering.less}
    .return {FOrdering.equal}
  }

//---File either.fear
package base

Either[A,B]:{
  mut  .match[R](m: mut EitherMatch[A, B, R]): R,
  read .match[R](m: mut EitherMatch[read A, read B, R]): R,
  imm  .match[R](m: mut EitherMatch[imm A, imm B, R]): R,
  }
EitherMatch[A,B,R]:{
  mut .a(x: A): R,
  mut .b(x: B): R,
  }

//---File errors.fear
package base

Error:{
  ![R:read,mut,imm,iso,lent,readOnly](info: Info): R -> Magic!,
  .str[R:read,mut,imm,iso,lent,readOnly](s: Str): R -> this!{
    .str -> s,
    .list -> List#,
    .map -> EmptyMap[Str, Info]
    }
  }

Todo:{
  ![R:read,mut,imm,iso,lent,readOnly]: R -> Error.msg[R] "TODO: Implement this code",
  ![R:read,mut,imm,iso,lent,readOnly](msg: Str): R -> Error.msg[R]("TODO: "+msg),
}

Try:{
  #[R](try: read Try[R]): mut Res[R] -> Magic!,
  }

Try[R]:{ read #: R, }

Info:Sealed{
  .str: Str,
  .map: Map[Str, Info],
  .list: List[Info],
  }
FInfo: {
  .str(str: Str): Info -> {
    .str -> str,
    .list -> List#,
    .map -> EmptyMap[Str, Info],
    },
  .list(list: List[Info]): Info -> {
    .str -> "",
    .list -> list,
    .map -> EmptyMap[Str, Info],
    },
  .map(map: Map[Str, Info]): Info -> {
    .str -> "",
    .list -> List#,
    .map -> map,
    },
  }

//---File extensions.fear
package base

Extensible[S]:{
  mut  .self: mut  S,
  read .self: read S,
  imm  .self: imm  S,

  mut  #[R](ext: mut Extension[mut  S, R]): R -> ext#(this.self),
  read #[R](ext: mut Extension[read S, R]): R -> ext#(this.self),
  imm  #[R](ext: mut Extension[imm  S, R]): R -> ext#(this.self),
  }
Extension[S,R]:{ mut #(self: S): R }


//---File flows\converters.fear
package base.flows

_MutSourceCollection[E]: {
  #(source: mut FlowOp[E]): mut Flow[E] -> Flow.fromOp(Block#
    .let[mut Ref[mut Opt[mut FlowOp[E]]]] cloned = {Ref#[mut Opt[mut FlowOp[E]]]{}}
    .return{{
      .isRunning -> this.get(cloned, source).isRunning,
      .stop -> this.get(cloned, source).stop,
      .step(downstream) -> this.get(cloned, source).step(downstream),
      }}),
  .get(cloned: mut Ref[mut Opt[mut FlowOp[E]]], original: mut FlowOp[E]): mut FlowOp[E] -> cloned.get.match{
     .some(cloned') -> cloned',
     .empty -> Block#
       .let[mut List[E]] dup = {Flow.fromOp(original).list}
       .do {cloned := (Opt#(Block#[mut FlowOp[E]]
         .let[mut Count[UInt]] cursor = {Count.uint(0u)}
         .return {{'self
           .isRunning -> cursor* < (dup.size),
           .stop -> cursor := (dup.size),
           .step(downstream) -> dup.get(cursor++).match{
             .some(x) -> downstream#x,
             .empty -> Block#(downstream.stop, self.stop),
             },
           }}))}
       .return{cloned.get!},
     },
  }

_FlowConverters: Sealed{
  }

_SafeSource: {

  .fromList[E](list: mut List[E]): mut Flow[E] -> Flow.fromOp[E](this.fromList'[E](list), list.size),
  .fromList'[E](list: mut List[E]): mut FlowOp[E] -> Block#
    .let[mut Count[UInt]] cursor = {Count.uint(0u)}
    .return {{'self
      .isRunning -> cursor* < (list.size),
      .stop -> cursor := (list.size),
      .step(downstream) -> list.get(cursor++).match{
        .some(x) -> Block#
          .do {downstream#x}
          .if {cursor.get >= (list.size)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .empty -> Block#(downstream.stop, self.stop),
        },
      }},
  }

//---File flows\flows.fear
package base.flows
alias base.Todo as Todo,

Flow: Sealed, _FlowExtensions, _FlowConverters{
  #[E]: mut Flow[E] -> mut EmptyFlow[E],
  #[E](e: E): mut Flow[E] -> _SeqFlow#[E](e),
  #[E](e1: E, e2: E): mut Flow[E] -> List#(e1, e2).flow,
  #[E](e1: E, e2: E, e3: E): mut Flow[E] -> List#(e1, e2, e3).flow,
  #[E](e1: E, e2: E, e3: E, e4: E): mut Flow[E] -> List#(e1, e2, e3, e4).flow,

  .fromOp[E](source: mut FlowOp[E]): mut Flow[E] -> _SeqFlow.fromOp(source, {}),
  .fromOp[E](source: mut FlowOp[E], size: UInt): mut Flow[E] -> _SeqFlow.fromOp(source, Opt#size),

  .fromMutSource[E](source: mut FlowOp[E]): mut Flow[E] -> _MutSourceCollection[E]#source,
  .fromMutSource[E](source: mut FlowOp[E], size: UInt): mut Flow[E] -> _MutSourceCollection[E]#source,
  }

Flow[E]: Sealed, Extensible[Flow[E]], _NonTerminalOps[E], _TerminalOps[E]{
  .self -> this,
  }

_NonTerminalOps[E]: {
  mut .filter(predicate: read F[E, Bool]): mut Flow[E],
  mut .map[R](f: read F[E, R]): mut Flow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R],

  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] -> this.actor[S,R](state, f, {_ -> {}}),
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] -> this.actorMut[S,R](state, f, {_ -> {}}),
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R],

  mut .limit(n: UInt): mut Flow[E],

  mut .scan[S:imm](acc: S, f: read F[S,E,S]): mut Flow[S] -> this.actor[mut Ref[S], S](Ref#[S]acc, {downstream, acc', e -> Block#(
    acc' := (f#(acc'.get, e)),
    downstream#(acc'.get),
    ActorRes.continue
    )}),
  }
_TerminalOps[E]: Sealed{
  mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R],
  mut .find(predicate: read F[E, Bool]): mut Opt[E],
  mut .any(predicate: read F[E, Bool]): Bool,
  mut .all(predicate: read F[E, Bool]): Bool,
  mut .fold[S](acc: S, f: read F[S,E,S]): S,
  mut .fold[S](acc: S, f: read F[S,E,S], combine: read F[S, S, S]): S,
  mut .size: UInt,

  mut .for(f: read F[E, Void]): Void -> this.fold(Void, {_, e -> f#e}),
  mut .list: mut List[E] -> this.fold(List#[E], {acc, e -> Block#(acc.add(e), acc)}),
  mut .max(compare: read F[E, E, Ordering]): mut Opt[E] -> this.fold[mut Opt[E]]({}, {max, b -> max.match{
    .empty -> Opt#b,
    .some(a) -> compare#(a, b).match{
      .less -> Opt#b,
      .equal -> max,
      .greater -> max,
      }
    }}, {a, b -> a.match{
      .empty -> b,
      .some(a') -> b.match{
        .empty -> a,
        .some(b') -> compare#(a', b').match{
          .less -> b,
          .equal -> a,
          .greater -> a,
          }
        }
      }})
  }

_FlowExtensions: {
  .str(separator: Str): mut Extension[mut Flow[Str], Str] -> {flow -> flow.fold[Str]("", {acc, str -> acc.size == 0u ? {
    .then -> acc + str,
    .else -> acc + separator + str,
    }})},

  .sum: mut Extension[mut Flow[Int], Int] -> {flow -> flow.fold[Int](0, {acc, e -> acc + e})},
  .uSum: mut Extension[mut Flow[UInt], UInt] -> {flow -> flow.fold[UInt](0u, {acc, e -> acc + e})},
  .fSum: mut Extension[mut Flow[Float], Float] -> {flow -> flow.fold[Float](0.0, {acc, e -> acc + e})},
  }

EmptyFlow[E]: Flow[E]{
  .filter(p) -> this,
  mut .map[R](f: read F[E, R]): mut Flow[R] -> mut EmptyFlow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R] -> mut EmptyFlow[R],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R] -> Block#(
    onComplete#state,
    mut EmptyFlow[imm R]),
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R] -> Block#(
    onComplete#state,
    mut EmptyFlow[R]),
  .limit(_) -> this,
  .findMap(_) -> {},
  .find(_) -> {},
  .any(p) -> False,
  .all(p) -> False,
  .fold(acc, _) -> acc,
  .fold(acc, _, _) -> acc,
  .size -> 0u,
  }

TerminalOnInfiniteError: { #: Info -> FInfo.msg "Terminal operators cannot be called on infinite flows. Use an operation like .limit(5u) to bound the flow." }

//---File flows\operators.fear
package base.flows


FlowOp[E]: {
  mut .step(sink: mut _Sink[E]): Void,
  mut .stop: Void,
  mut .isRunning: Bool,
  mut .forRemaining(downstream: mut _Sink[E]): Void -> Block#
    .do{this.step(downstream)}
    .if {this.isRunning.not} .return {{}}
    .return {this.forRemaining(downstream)},
  mut .isFinite: Bool -> True,
  mut .split: mut Opt[mut FlowOp[E]] -> {},
  }


_Sink: {
  #[T](s: mut _Sink[T]): mut _Sink[T] -> s,
  }
_Sink[T]: {
  mut #(x: T): Void,
  mut .stop: Void,
  }


_Filter: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], predicate: read F[E, Bool]): mut FlowOp[E] -> Block#
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> predicate#e ? {.then -> downstream#e, .else -> {}},
            })),
          upstream.step(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      }}
  }
_Map: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, R]): mut FlowOp[R] -> Block#
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return  {{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#e),
            })),
          upstream.step(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
    }}
  }
_FlatMap: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, mut Flow[R]]): mut FlowOp[R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opt#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> f#e.list.iter.filter{_ -> op.isRunning}.for{e' -> downstream#e'},
            })),
          upstream.step(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> isRunning*,
      }}
  }

//---File flows\par.fear
package base.flows

_PipelineParallelSink: _Sink{
  #[T](s: mut _Sink[T]): mut _PipelineParallelSink[T] -> Magic!,
  }
_PipelineParallelSink[T]: _Sink[T]

_PipelineParallelFlow: {
  .fromOp[E](source: mut FlowOp[E], size: Opt[UInt]): mut Flow[E] -> {'self
    .filter(p) -> this.fromOp(_Filter#(_PipelineParallelSink, source, p), {}),
    .map(f) -> this.fromOp(_Map#(_PipelineParallelSink, source, f), size),
    .flatMap(f) -> this.fromOp(_FlatMap#(_PipelineParallelSink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_PipelineParallelSink, source, state, f, onComplete), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_PipelineParallelSink, source, state, f, onComplete), {}),
    .limit(n) -> this.fromOp(_Limit#(_PipelineParallelSink, source, n), size),

    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .let[mut Ref[mut Opt[R]]] res = {Ref#mut Opt[R]}
      .do {source.forRemaining(_PipelineParallelSink#[E]{'runner
        .stop -> source.stop,
        #(e) -> f#e.match{.some(e') -> Block#(res := (Opt#e'), runner.stop), .empty -> {}},
        })}
      .do {source.stop}
      .return {res.get},

    .find(p) -> self.findMap{e -> p#e ? {.then -> Opt#e, .else -> {}}},
    .any(p) -> self
      .findMap{e -> p#e ? {.then -> Opt#True, .else -> {}}}
      .isSome,
    .all(p) -> self
      .findMap{e -> p#e ? {.then -> {}, .else -> Opt#False}}
      .isEmpty,

    mut .fold[S](acc: S, f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .let[mut Ref[S]] acc' = {Ref#acc}
      .do {source.forRemaining(_PipelineParallelSink#[E]{
        .stop -> {},
        #(e) -> acc' := (f#(acc'.get, e)),
        })}
      .do {source.stop}
      .return {acc'.get},
    .fold(acc, f, combine) -> self.fold(acc, f),

    .size -> size.match[UInt]{
      .some(n) -> n,
      .empty -> self.fold[UInt](0u, {acc, _ -> acc + 1u}),
      },
    },

  #[E](e: E): mut Flow[E] -> Block#
    .let[mut Ref[mut Opt[E]]] seq = { Ref#(Opt#e) }
    .let[mut FlowOp[E]] source = {{ 'self
      .isRunning -> seq.get.isSome,
      .stop -> seq := {},
      .step(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, self.stop),
        },
      .forRemaining(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> Block#(downstream#x, downstream.stop, self.stop),
        .empty -> Block#(downstream.stop, self.stop),
        },
      }}
    .return {this.fromOp(source, Opt#[UInt]1u)},
  }

//---File flows\pkg.fear
package base.flows

alias base.Block as Block,
alias base.Sealed as Sealed,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.UInt as UInt, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.F as F, alias base.Consumer as Consumer,
alias base.Extensible as Extensible, alias base.Extension as Extension,
alias base.Ref as Ref, alias base.Count as Count,
alias base.Opt as Opt,
alias base.Let as Let,
alias base.List as List,
alias base.Error as Error, alias base.FInfo as FInfo, alias base.Info as Info,
alias base.Ordering as Ordering,
alias base.Magic as Magic,
alias base.IsoPod as IsoPod,

//---File flows\seq.fear
package base.flows

_SeqFlow: {
  .fromOp[E](source: mut FlowOp[E], size: Opt[UInt]): mut Flow[E] -> {'self
    .filter(p) -> this.fromOp(_Filter#(_Sink, source, p), {}),
    .map(f) -> this.fromOp(_Map#(_Sink, source, f), size),
    .flatMap(f) -> this.fromOp(_FlatMap#(_Sink, source, f), {}),
    mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut Flow[imm R] ->
      this.fromOp(_Actor#[S,E,R](_Sink, source, state, f, onComplete), {}),
    mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut Flow[R] ->
      this.fromOp(_Actor.anyRet[S,E,R](_Sink, source, state, f, onComplete), {}),
    .limit(n) -> this.fromOp(_Limit#(_Sink, source, n), size),

    mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R] -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .let[mut Ref[mut Opt[R]]] res = {Ref#mut Opt[R]}
      .do {source.forRemaining(mut _Sink[E]{'runner
        .stop -> {},
        #(e) -> f#e.match{.some(e') -> Block#(res := (Opt#e'), runner.stop), .empty -> {}},
        })}
      .do {source.stop}
      .return {res.get},

    .find(p) -> self.findMap{e -> p#e ? {.then -> Opt#e, .else -> {}}},
    .any(p) -> self
      .findMap{e -> p#e ? {.then -> Opt#True, .else -> {}}}
      .isSome,
    .all(p) -> self
      .findMap{e -> p#e ? {.then -> {}, .else -> Opt#False}}
      .isEmpty,

    mut .fold[S](acc: S, f: read F[S,E,S]): S -> Block#
      .if {source.isFinite.not} .error {TerminalOnInfiniteError#}
      .let[mut Ref[S]] acc' = {Ref#acc}
      .do {source.forRemaining(mut _Sink[E]{
        .stop -> {},
        #(e) -> acc' := (f#(acc'.get, e)),
        })}
      .do {source.stop}
      .return {acc'.get},
    .fold(acc, f, combine) -> self.fold(acc, f),

    .size -> size.match[UInt]{
      .some(n) -> n,
      .empty -> self.fold[UInt](0u, {acc, _ -> acc + 1u}),
      },
    },

  #[E](e: E): mut Flow[E] -> Block#
    .let[mut Ref[mut Opt[E]]] seq = { Ref#(Opt#e) }
    .let[mut FlowOp[E]] source = {{ 'self
      .isRunning -> seq.get.isSome,
      .stop -> seq := {},
      .step(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, self.stop),
        },
      .forRemaining(downstream) -> seq.swap(mut Opt[E]).match{
        .some(x) -> Block#(downstream#x, downstream.stop, self.stop),
        .empty -> Block#(downstream.stop, self.stop),
        },
      }}
    .return {this.fromOp(source, Opt#[UInt]1u)},
  }

//---File flows\statefulOperators.fear
package base.flows

_Limit: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], n: UInt): mut FlowOp[E] -> Block#
    .let[mut Count[UInt]] remaining = {Count.uint(n)}
    .let[mut Ref[mut Opt[mut _Sink[E]]]] sink = {Ref#{}}
    .return {{ 'runner
      .stop -> Block#(remaining := 0u, upstream.stop),
      .isRunning -> remaining* > 0u && (upstream.isRunning),
      .isFinite -> True,
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#
          .if {n == 0u} .return {runner.stop}
          .do {sink := (Opt#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> remaining* == 0u || (remaining-- == 0u) ? {
              .then -> runner.stop,
              .else -> downstream#e
              }
            }))}
          .return {upstream.step(sink.get!)}
        },
      }},
  }

_Actor: {
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut FlowOp[imm R] ->
    _InternalActor#[S,E,R](sinkFactory, upstream, state, f, onComplete),

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: iso S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut FlowOp[R] ->
    _InternalActor.anyRet[S,E,R](sinkFactory, upstream, state, f, onComplete),
  }
_InternalActor: {
  #[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: S, f: read ActorImpl[S,E,R], onComplete: mut Consumer[S]): mut FlowOp[imm R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop, onComplete#state),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> upstream.step(sinkFactory#[E]{
        .stop -> Block#(downstream.stop, op.stop),
        #(e) -> f#(downstream, state, e).match{
          .continue -> {},
          .stop -> Block#(downstream.stop, isRunning := False, onComplete#state),
          },
        }),
      }},

  .anyRet[S,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], state: mut S, f: read ActorImplMut[S,E,R], onComplete: mut Consumer[mut S]): mut FlowOp[R] -> Block#
    .let[mut Ref[Bool]] isRunning = {Ref#[Bool]True}
    .return {{'op
      .stop -> op.isRunning ? {
       .then -> Block#(isRunning := False, upstream.stop, onComplete#state),
       .else -> {}
       },
      .isRunning -> isRunning*,
      .step(downstream) -> upstream.step(sinkFactory#[E]{
        .stop -> Block#(downstream.stop, op.stop),
        #(e) -> f#(downstream, state, e).match{
          .continue -> {},
          .stop -> Block#(downstream.stop, isRunning := False, onComplete#state),
          },
        }),
      }},
  }

ActorImpl[S,E,R]: { read #(downstream: mut _Sink[imm R], state: S, e: E): ActorRes }
ActorImplMut[S,E,R]: { read #(downstream: mut _Sink[R], state: lent S, e: E): ActorRes }

ActorRes: Sealed{
  .match[R](m: mut ActorResMatch[R]): R -> m.continue,
  .continue: ActorRes -> {.match(m) -> m.continue},
  .stop: ActorRes -> {.match(m) -> m.stop},
  }
ActorResMatch[R]: { mut .continue: R, mut .stop: R, }

//---File flows.fear
package base

alias base.flows.Flow as Flow,
alias base.flows.FlowOp as FlowOp,
alias base.flows.ControlFlow as FlowCtrl,
alias base.flows._Sink as FlowSink,

//---File iter\automatons.fear
package base.iter.automatons
alias base.F as F,
alias base.Opt as Opt,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.Let as Let,
alias base.Block as Block,



//---File iter\flows.fear
package base.iter

alias base.flows.Flow as Flow,
alias base.flows.FlowOp as FlowOp,
alias base.flows.ControlFlow as FlowCtrl,
alias base.flows._Sink as FlowSink,

//---File iter\iter.fear
package base.iter

Iter[E]:{
  mut .next: mut Opt[E],
  mut .find(p: mut IterPredicate[E]): mut Opt[E] -> this.next.match[mut Opt[E]]{
    .some(x) -> p#x ? { .then -> Opt#x, .else -> this.find(p) },
    .empty -> {}
    },
  mut .allMatch(p: mut IterPredicate[E]): Bool -> this.find{x -> p#x .not}.match[Bool]{
    .some(_) -> False,
    .empty -> True
    },
  mut .anyMatch(p: mut IterPredicate[E]): Bool -> this.find(p).match[Bool]{
    .some(_) -> True,
    .empty -> False
    },

  mut .map[R](f: mut IterMapper[E, R]): mut Iter[R] -> { this.next.map[R](f) },
  mut .flatMap[R](f: mut IterMapper[E, mut Iter[R]]): mut Iter[R] -> Block#
    .let[mut Iter[mut Iter[R]]] mapIter = { this.map(f) }
    .let[mut Ref[mut Opt[mut Iter[R]]]] optCurIter = { Ref#(mapIter.next) }
    .return(mut ReturnStmt[mut Iter[R]]{ mut Iter[R]{ 'self
      .next -> optCurIter*[].match[mut Opt[R]]{
        .some(curIter) -> curIter.next.match[mut Opt[R]]{
          .some(next) -> Opt#next,
          .empty -> Block#(optCurIter := (mapIter.next), self.next)
          },
        .empty -> {}
        }
      }}),
  mut .filter(p: mut IterPredicate[E]): mut Iter[E] -> { .next -> this.find(p) },

  mut .fold[R](acc: R, f: mut IterFolder[E, R]): R -> this.next.match[R]{
    .some(e) -> this.fold(f#(acc, e), f),
    .empty -> acc
    },
  mut .for(f: mut IterForEacher[E]): Void -> this.next.match[Void]{
    .some(e) -> Block#(f#e, this.for(f)),
    .empty -> {}
    },

  mut .count: UInt -> this.fold[UInt](0u, mut IterFolder[E, UInt]{ acc, _ -> acc + 1u }),
  mut .list: mut List[E] -> this.fold(List#[E], { acc, e -> Block#(acc.add(e), acc) }),
  mut .llist: mut LList[E] -> this.fold(mut LList[E], { acc, e -> acc +[] e }),
  mut .str(toStr: mut IterMapper[E, Str], joining: Str): Str -> this.map(toStr)
    .fold[Str]("", mut IterFolder[Str, Str]{ acc, e -> acc.size == 0u ? { .then -> acc + e,
                                                                          .else -> acc + joining + e }}),
  }

Sum:{
  .int(ns: mut Iter[Int]): Int -> ns.fold[Int](0, mut IterFolder[Int, Int]{ acc, n -> acc + n }),
  .uint(ns: mut Iter[UInt]): UInt -> ns.fold[UInt](0u, mut IterFolder[UInt, UInt]{ acc, n -> acc + n }),
  .float(ns: mut Iter[Float]): Float -> ns.fold[Float](0.0, mut IterFolder[Float, Float]{ acc, n -> acc + n }),
  }

IterForEacher[E]:{ mut #(e: E): Void }
IterFolder[E,R]:{ mut #(acc: R, e: E): R }
IterScanner[E, R, S]:{ lent #(state: mut Ref[S], e: E): S }
IterMapper[E,R]:OptMap[E, R]
IterPredicate[E]:{ mut #(e: E): Bool }


//---File iter\pariter\iter.fear
package base.iter.par

Iter[E]:{
  .cur: Opt[imm E],
  .next: Iter[imm E],
  .find(p: IterPredicate[imm E]): Opt[imm E] -> this.cur.match[Opt[imm E]]{
    .some(x) -> p#x ? { .then -> Opt#x, .else -> this.next.find(p) },
    .empty -> {}
    },
  .allMatch(p: IterPredicate[imm E]): Bool -> this.find{x -> p#x .not}.match[Bool]{
    .some(_) -> False,
    .empty -> True
    },
  .anyMatch(p: IterPredicate[imm E]): Bool -> this.find(p).match[Bool]{
    .some(_) -> True,
    .empty -> False
    },

  .map[R](f: IterMapper[imm E, imm R]): Iter[imm R] -> {
    .cur -> this.cur.map[imm R]{ e -> f#e },
    .next -> this.next.map[imm R](f),
    },
  .flatMap[R](f: IterMapper[imm E, Iter[imm R]]): Iter[imm R] -> _FlatMap[imm R].outer(this.map(f)),
  .filter(p: IterPredicate[imm E]): Iter[imm E] -> this.cur.match[Iter[imm E]]{
    .some(x) -> p#x ? {
      .then -> { .cur -> this.cur, .next -> this.next.filter(p) },
      .else -> this.next.filter(p),
      },
    .empty -> _Empty[imm E]
    },

  .fold[R](acc: R, f: IterFolder[imm E, R]): R -> this.cur.match[R]{
    .some(e) -> this.next.fold(f#(acc, e), f),
    .empty -> acc
    },
  .for(f: mut IterForEacher[imm E]): Void -> this.cur.match[Void]{
    .some(e) -> Block#(f#e, this.next.for(f)),
    .empty -> {}
    },

  .count: UInt -> this.fold[UInt](0u, IterFolder[imm E, UInt]{ acc, _ -> acc + 1u }),
  .list: mut List[imm E] -> this.fold(List#[imm E], { acc, e -> Block#(acc.add(e), acc) }),
  .llist: mut LList[imm E] -> this.fold(mut LList[imm E], { acc, e -> acc +[] e }),
  .str(toStr: IterMapper[imm E, Str], joining: Str): Str -> this.map(toStr)
    .fold[Str]("", IterFolder[Str, Str]{ acc, e -> acc.size == 0u ? { .then -> acc + e,
                                                                       .else -> acc + joining + e }})
  }

Sum:{
  .int(ns: Iter[Int]): Int -> ns.fold[Int](0, IterFolder[Int, Int]{ acc, n -> acc + n }),
  .uint(ns: Iter[UInt]): UInt -> ns.fold[UInt](0u, IterFolder[UInt, UInt]{ acc, n -> acc + n }),
  .float(ns: Iter[Float]): Float -> ns.fold[Float](0.0, IterFolder[Float, Float]{ acc, n -> acc + n }),
  }

IterForEacher[E]:{ mut #(e: imm E): Void }
IterFolder[E,R]:{ #(acc: R, e: imm E): R }
IterMapper[E,R]:{ #(e: imm E): imm R }
IterPredicate[E]:{ #(e: imm E): Bool }

_FlatMap[R]:Sealed{
  .outer(mapIter: Iter[Iter[R]]): Iter[R] -> mapIter.cur.match[Iter[R]]{
    .some(inner) -> this.inner(mapIter, inner),
    .empty -> _Empty[R]
    },
  .inner(mapIter: Iter[Iter[R]], curIter: Iter[R]): Iter[R] -> curIter.cur.match{
    .some(cur) -> { .cur ->  Opt#cur, .next -> this.inner(mapIter, curIter.next) },
    .empty -> this.outer(mapIter.next),
    }
}
_Empty[E]:Iter[imm E]{ .cur -> {}, .next -> this }

//---File iter\pariter\pkg.fear
package base.iter.par
alias base.LList as LList, alias base.List as List,
alias base.Opt as Opt, alias base.OptMap as OptMap, alias base.OptMatch as OptMatch,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.UInt as UInt, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.Let as Let,
alias base.Block as Block, alias base.ReturnStmt as ReturnStmt,
alias base.Ref as Ref,
alias base.Sealed as Sealed,
alias base.As as As,
alias base.F as F,
alias base.caps.IsoPod as IsoPod,

//---File iter\pkg.fear
package base.iter
alias base.LList as LList, alias base.List as List,
alias base.Opt as Opt, alias base.OptMap as OptMap, alias base.OptMatch as OptMatch,
alias base.Void as Void,
alias base.Bool as Bool, alias base.True as True, alias base.False as False,
alias base.UInt as UInt, alias base.Int as Int, alias base.Float as Float,
alias base.Str as Str,
alias base.Let as Let,
alias base.Block as Block, alias base.ReturnStmt as ReturnStmt,
alias base.Ref as Ref,
alias base.Sealed as Sealed,

//---File lang.fear
package base
alias base.caps.System as System,

Main: { #(s: mut System): Void }
Sealed: {}
Void: Sealed{}

Abort: Sealed{ ![R:readOnly,lent,read,mut,imm,iso]: R -> this! } // can be optimised to just terminate (goes stuck)
Magic: Sealed{ ![R:readOnly,lent,read,mut,imm,iso]: R -> this! } // magic'd out to tell us what we forgot to implement
Debug: Sealed{ #[T](x: T): T -> x }
HasIdentity: { mut .idEq(other: readOnly HasIdentity): Bool -> Magic! } // TODO: magic

As[X:imm,mut,read,iso]: Sealed{ #(x: X): X -> x }

Let: {
  #[V,R](l: mut Let[V, R]): R -> l.in(l.var),
  }
Let[V,R]: { mut .var: V, mut .in(v: V): R }

F[R:read,mut,imm,iso]: { read #: R }
F[A:read,mut,imm,iso,R:read,mut,imm,iso]: { read #(a: A): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B): R }
F[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso, R:read,mut,imm,iso]: { read #(a: A, b: B, c: C): R }

Consumer[A:read,mut,imm,iso]: { mut #(a: A): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso]: { mut #(a: A, b: B): Void }
Consumer[A:read,mut,imm,iso, B:read,mut,imm,iso, C:read,mut,imm,iso]: { mut #(a: A, b: B, c: C): Void }

ToImm[R]: { readOnly .toImm: imm R, }
Freezer[T,R]: { mut #(self: T): imm R }
Ice[T]: { readOnly .get: imm T }

Box[T]: {
  mut  .get: T,
  read .get: read T,
  imm  .get: imm T,
  }

//---File lists.fear
package base

Collection:{
  read .size: UInt,
  read .isEmpty: Bool,
  }

LList:{ #[E]: mut LList[E] -> mut LList[E] }
LList[E]:Collection,Sealed{
  mut  .match[R](m: mut LListMatch[E, R]): R -> m.empty,
  read .match[R](m: mut LListMatchRead[read E, R]): R -> m.empty,

  mut  .get(i: UInt): mut Opt[E] -> {},
  read .get(i: UInt): mut Opt[read E] -> {},
  imm  .get(i: UInt): iso Opt[imm E] -> {},

  mut  .head: mut Opt[E] -> {},
  read .head: mut Opt[read E] -> {},
  imm  .head: iso Opt[imm E] -> {},

  mut  .tail: mut LList[E] -> this,
  read .tail: read LList[read E] -> this,
  imm  .tail: LList[imm E] -> this,

  mut  ++(l1: mut LList[E]): mut LList[E] -> l1,
  read ++(l1: read LList[read E]): read LList[read E] -> l1,
  imm ++(l1: LList[imm E]): LList[imm E] -> l1,

  mut  +(e: E): mut LList[E] -> this ++ (mut LList[E].pushFront[](e)),
  read +(e: read E): read LList[read E] -> this ++ (read LList[read E].pushFront[](e)),
  imm  +(e: imm E): LList[imm E] -> this ++ (LList[imm E].pushFront[](e)),

  mut .iter: mut Iter[E] -> Let#{
    .var -> Ref#this,
    .in(cursor) -> { .next -> (cursor.swap[](cursor*[].tail[])).head[] }
    },
  imm .iter: mut Iter[imm E] -> Let#{
    .var -> Ref#this,
    .in(cursor) -> { .next -> (cursor.swap[](cursor*[].tail[])).head[] }
    },
  read .iter: mut Iter[read E] -> Let#{
    .var -> Ref#this,
    .in(cursor) -> { .next -> (cursor.swap[](cursor*[].tail[])).head[] }
    },

  mut  .flow: mut Flow[E] -> Block#
    .var cursor = {Ref#this}
    .return {Flow.fromMutSource{'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> (cursor.swap(cursor*.tail)).head.match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, op.stop),
        },
      }},
  read .flow: mut Flow[read E] -> Flow.fromOp[read E](this._flowread),
  read ._flowread: mut FlowOp[read E] -> Block#
    .var cursor = {Ref#this}
    .return {mut FlowOp[read E]{'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> (cursor.swap(cursor*.tail)).head.match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, op.stop),
        },
      }},
  imm  .flow: mut Flow[imm E] -> Flow.fromOp[imm E](this._flowimm),
  imm  ._flowimm: mut FlowOp[imm E] -> Block#
    .var cursor = {Ref#this}
    .return {mut FlowOp[imm E]{'op
      .stop -> cursor := {},
      .isRunning -> cursor*.isEmpty.not,
      .step(downstream) -> (cursor.swap(cursor*.tail)).head.match{
        .some(x) -> downstream#x,
        .empty -> Block#(downstream.stop, op.stop),
        },
      }},

  read .isEmpty: Bool -> True,
  read .size: UInt -> 0u,

  mut .list: mut List[E] -> List.fromLList[E](this),

  mut .pushFront(e: E): mut LList[E] -> Let#{
    .var -> this.size + 1u,
    .in(len) -> {'l
      mut  .match[R](m: mut LListMatch[E, R]): R -> m.elem(e, this),
      read .match[R](m: mut LListMatchRead[read E, R]): R -> m.elem(e, this),
      imm  .match[R](m: mut LListMatchRead[imm E, R]): R -> m.elem(e, this),

      mut  .get(i: UInt): mut Opt[E] -> (i == 0u) ? { .then -> Opt#e, .else -> this.get[](i - 1u) },
      read .get(i: UInt): mut Opt[read E] -> (i == 0u) ? { .then -> Opt#[read E]e, .else -> this.get[](i - 1u) },
      imm  .get(i: UInt): iso Opt[imm E] -> (i  == 0u) ? { .then -> Opt#[imm E]e, .else -> this.get[](i - 1u) },

      mut  .head: mut Opt[E] -> Opt#e,
      read .head: mut Opt[read E] -> Opt#[read E]e,
      imm  .head: iso Opt[imm E] -> Opt#[imm E]e,

      .tail -> this,
      ++(l1) -> (this ++ l1).pushFront[](e),
      .isEmpty -> False,
      .size -> len,
      }
    },
  read .pushFront(e: read E): read LList[read E] -> Let#{
    .var -> this.size + 1u,
    .in(len) -> {'l
      read .match[R](m: mut LListMatchRead[read E, R]): R -> m.elem(e, this),
      imm  .match[R](m: mut LListMatchRead[imm E, R]): R -> m.elem(e, this),

      read .get(i: UInt): mut Opt[read E] -> (i == 0u) ? { .then -> Opt#e, .else -> this.get[](i - 1u) },
      imm  .get(i: UInt): iso Opt[imm E] -> (i == 0u) ? { .then -> Opt#[imm E]e, .else -> this.get[](i - 1u) },

      read .head: mut Opt[read E] -> Opt#e,
      imm  .head: iso Opt[imm E] -> Opt#[imm E]e,
      .tail -> this,
      ++(l1) -> (this ++ l1).pushFront[](e),
      .isEmpty -> False,
      .size -> len,
      }
    },
  }
LListMatch[E,R]:{
  mut .elem(head: E, tail: mut LList[E]): R,
  mut .empty: R,
  }
LListMatchRead[E,R]:{
  mut .elem(head: read E, tail: read LList[read E]): R,
  mut .empty: R,
  }

List:{
  #[E]: mut List[E] -> _List.new(Ref#(_ListState#[E](0u, {}))),
  #[E](e1: E): mut List[E] -> this.fromLList[E](mut LList[E].pushFront(e1)),
  #[E](e1: E, e2: E): mut List[E] -> this.fromLList[E](mut LList[E].pushFront(e2).pushFront(e1)),
  #[E](e1: E, e2: E, e3: E): mut List[E] -> this.fromLList[E](mut LList[E].pushFront(e3).pushFront(e2).pushFront(e1)),
  #[E](e1: E, e2: E, e3: E, e4: E): mut List[E] -> this.fromLList[E](mut LList[E].pushFront(e4).pushFront(e3).pushFront(e2).pushFront(e1)),
  .fromLList[E](list: mut LList[E]): mut List[E] -> _List.new(Ref#(_ListState#[E](list.size, list))),
  }
_List:{
  .new[E](s: mut Ref[mut _ListState[E]]): mut List[E] -> {'l
    .size -> s*.size,
    .isEmpty -> s*.inner.isEmpty,
    .get(i) -> s*.inner.get(i),
    .add(e) -> s := (_ListState#[E](s*.size + 1u, s*.inner + e)),
    }
  }
List[E]: Collection,Sealed{
  mut  .get(i: UInt): mut Opt[E],
  read .get(i: UInt): mut Opt[read E],
  imm  .get(i: UInt): iso Opt[imm E],
  mut .add(e: E): Void,
  mut .addAll(other: mut List[E]): Void -> other.iter.for{ e -> this.add(e) },

  mut .flow: mut Flow[E] -> Block#
    .let[mut Count[UInt]] cursor = {Count.uint(0u)}
    .return {Flow.fromMutSource({'self
      .isRunning -> cursor* < (this.size),
      .stop -> cursor := (this.size),
      .step(downstream) -> this.get(cursor++).match{
        .some(x) -> Block#
          .do {downstream#x}
          .if {cursor.get >= (this.size)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .empty -> Block#(downstream.stop, self.stop),
        },
      }, this.size)},
  read .flow: mut Flow[read E] -> Flow.fromOp(this._flowread, this.size),
  read ._flowread: mut FlowOp[read E] -> Block#
    .let[mut Count[UInt]] cursor = {Count.uint(0u)}
    .return {{'self
      .isRunning -> cursor* < (this.size),
      .stop -> cursor := (this.size),
      .step(downstream) -> this.get(cursor++).match{
        .some(x) -> Block#
          .do {downstream#x}
          .if {cursor.get >= (this.size)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .empty -> Block#(downstream.stop, self.stop),
        },
      }},
  imm .flow: mut Flow[imm E] -> Flow.fromOp(this._flowimm, this.size),
  imm ._flowimm: mut FlowOp[imm E] -> Block#
    .let[mut Count[UInt]] cursor = {Count.uint(0u)}
    .return {{'self
      .isRunning -> cursor* < (this.size),
      .stop -> cursor := (this.size),
      .step(downstream) -> this.get(cursor++).match{
        .some(x) -> Block#
          .do {downstream#x}
          .if {cursor.get >= (this.size)} .do {Block#(downstream.stop, self.stop)}
          .return {{}},
        .empty -> Block#(downstream.stop, self.stop),
        },
      }},


  mut .iter: mut Iter[E] -> Let#{
    .var -> Count.uint(0u),
    .in(cursor) -> { .next -> this.get(cursor++) }
    },
  read .iter: mut Iter[read E] -> Let#{
    .var -> Count.uint(0u),
    .in(cursor) -> { .next -> this.get(cursor++) }
    },
  imm .iter: mut Iter[imm E] -> Let#{
    .var -> Count.uint(0u),
    .in(cursor) -> { .next -> this.get(cursor++) }
    },
  }
_ListParIter:{
  #[E](l: List[imm E], i: UInt): base.iter.par.Iter[imm E] -> {
    .cur -> l.get(i),
    .next -> this#(l, i + 1u),
    }
  }
_ListState[E]:{
  read .size: UInt,
  mut .inner: mut LList[E],
  read .inner: read LList[read E],
  }
_ListState:{
  #[E](len: UInt, inner: mut LList[E]): mut _ListState[E] -> {
    .size -> len,
    .inner -> inner
    }
  }

AppendList[E]: Collection{
  mut  .get(i: UInt): mut Opt[E],
  read .get(i: UInt): mut Opt[read E],
  imm  .get(i: UInt): iso Opt[imm E],
  mut .append(e: E): Void,
  }

//---File maps.fear
package base

Map[K:imm, V]:{
  read .keyEq(k1: K, k2: K): Bool,
  imm  .get(k: K): mut Opt[imm V] -> {},
  }

EmptyMap[K:imm,V]:Map[K, V]{
  .keyEq(k1, k2) -> False,
  .get(k) -> {},
  }

Lens[K: imm, V]:Map[K, imm V]{
  .put(k: K, v: imm V): mut Lens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    .get(k') -> next.keyEq(k, k') ? {.then -> Opt#v, .else -> this.get(k')}
    },
  .map[R](f: MapMapImm[K, imm V, imm R]): Lens[K, imm R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    .get(k) -> this.get(k).map{res -> f#(k, res)},
    },
  }

LinkedLens[K:imm, V]:Map[K, V]{
  imm  .get(k: K): mut Opt[imm V] -> {},
  mut  .get(k: K): mut Opt[V] -> {},
  read .get(k: K): mut Opt[read V] -> {},

  mut  .put(k: K, v: V): mut LinkedLens[K, V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opt#[imm V]v, .else -> this.get(k')},
    mut  .get(k': K): mut Opt[V] -> next.keyEq(k, k') ? {.then -> Opt#v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read V] -> next.keyEq(k, k') ? {.then -> Opt#[read V]v, .else -> this.get(k')},
    },
  read .put(k: K, v: read V): read LinkedLens[K, read V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opt#[imm V]v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read V] -> next.keyEq(k, k') ? {.then -> Opt#[read V]v, .else -> this.get(k')},
    },

  imm .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: MapMapRead[K, V, R]): LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map{res -> fRead#(k, res)},
    },
  mut .map[R](fImm: MapMapImm[K, imm V, imm R], fMut: mut MapMapMut[K, V, R], fRead: read MapMapRead[K, V, R]): mut LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    mut  .get(k: K): mut Opt[R] ->      this.get(k).map{res -> fMut#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map mut OptMap[read V, read R]{res -> fRead#(k, res)},
    },
  read .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: read MapMapRead[K, V, R]): read LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map{res -> fRead#(k, res)},
    },
  }

MapMapImm[K:imm,V,R]:{ #(k: K, v: imm V): R }
MapMapMut[K:imm,V,R]:{ mut #(k: K, v: V): R }
MapMapRead[K:imm,V,R]:{ read #(k: K, v: read V): read R }

//---File nums.fear
package base

Int:Sealed,_MathOps[imm Int],_IntOps[imm Int]{
  readOnly .uint: UInt,
  readOnly .float: Float,
  read .str: Str,
  }
UInt:Sealed,_MathOps[imm UInt],_IntOps[imm UInt]{
  readOnly .int: Int,
  readOnly .float: Float,
  read .str: Str,
  }
Float:Sealed,_MathOps[imm Float]{
  readOnly .int: Int,
  readOnly .uint: UInt,
  readOnly .round: Int,
  readOnly .ceil: Int,
  readOnly .floor: Int,
  readOnly **(n: readOnly Float): Float, // pow
  readOnly .isNaN: Bool,
  readOnly .isInfinite: Bool,
  readOnly .isPosInfinity: Bool,
  readOnly .isNegInfinity: Bool,
  read .str: Str,
  }

_MathOps[T]:Sealed{
  readOnly .toImm: T,
  readOnly +(n: readOnly T): T,
  readOnly -(n: readOnly T): T,
  readOnly *(n: readOnly T): T,
  readOnly /(n: readOnly T): T,
  readOnly %(n: readOnly T): T,
  readOnly .abs: T,

  readOnly >(n: readOnly T): Bool,
  readOnly <(n: readOnly T): Bool,
  readOnly >=(n: readOnly T): Bool,
  readOnly <=(n: readOnly T): Bool,
  readOnly ==(n: readOnly T): Bool,
  }
_IntOps[T]:Sealed{
  readOnly >>(n: readOnly T): T,
  readOnly <<(n: readOnly T): T,
  readOnly ^(n: readOnly T): T,
  readOnly &(n: readOnly T): T,
  readOnly |(n: readOnly T): T,

  readOnly **(n: readOnly UInt): T, // pow
  }

_IntInstance:Int{
  .uint -> Magic!,
  .float -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,

  >>(n) -> Magic!,
  <<(n) -> Magic!,
  ^(n) -> Magic!,
  &(n) -> Magic!,
  |(n) -> Magic!,

  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }
_UIntInstance:UInt{
  .int -> Magic!,
  .float -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,

  >>(n) -> Magic!,
  <<(n) -> Magic!,
  ^(n) -> Magic!,
  &(n) -> Magic!,
  |(n) -> Magic!,

  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }
_FloatInstance:Float{
  .int -> Magic!,
  .uint -> Magic!,
  .str -> Magic!,
  .round -> Magic!,
  .ceil -> Magic!,
  .floor -> Magic!,
  .isNaN -> Magic!,
  .isInfinite -> Magic!,
  .isPosInfinity -> Magic!,
  .isNegInfinity -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,
  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }

//---File optionals.fear
package base

Opt:{ #[T](x: T): mut Opt[T] -> {
   .match(m) -> m.some(x),
  }}
Opt[T]:Extensible[Opt[T]]{
  .self -> this,
  mut  .match[R](m: mut OptMatch[T, R]): R -> m.empty,
  read .match[R](m: mut OptMatch[read T, R]): R -> m.empty,
  imm  .match[R](m: mut OptMatch[imm T, R]): R -> m.empty,

  mut  !: T -> this.match[T](mut OptMatch[T, T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  read !: read T -> this.match[read T](mut OptMatch[read T, read T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  imm  !: imm T -> this.match[imm T](mut OptMatch[imm T, imm T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),

  mut .map[R](f: mut OptMap[T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  read .map[R](f: mut OptMap[read T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  imm  .map[R](f: mut OptMap[imm T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),


  read .isEmpty: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> True, .some(_) -> False }),
  read .isSome: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> False, .some(_) -> True }),

  mut  .flow: mut Flow[T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  imm  .flow: mut Flow[imm T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  read .flow: mut Flow[read T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  }

OptMatch[T,R]:{ mut .some(x: T): R, mut .empty: R }
OptOrElse[R]:{ mut #: R }
OptMap[T,R]:OptMatch[T, mut Opt[R]]{
  mut #(t: T): R,
  .some(x) -> Opt#(this#x),
  .empty -> {}
  }

OptOrElseExt[T]:Extension[mut Opt[T], T]{
  mut .alt: T,
  #(opt) -> opt.match{ .some(x) -> x, .empty -> this.alt }
  }

//---File pkg.fear
package base
alias base.iter.Iter as Iter,

//---File ref.fear
package base

Ref:{
  #[X](x: X): mut Ref[X] -> Magic!,
  readOnly #[X](x: imm X): mut RefImm[imm X] -> Ref.ofImm x,
  .ofImm[X](x: imm X): mut RefImm[imm X] -> Let#{
    .var -> Ref#(Ice[imm X]{x}),
      .in(ref) -> {
         mut  .get: imm X -> ref.get.get,
         read .get: imm X -> ref.get.get,
         .swap(newX) -> ref.swap(Ice[imm X]{newX}).get,
         }
      }
  }
Ref[X:imm,mut,read]:Sealed{
  mut  .get: X,
  read .get: read X,
  read .getImm(f: mut Freezer[read X, imm X]): imm X -> f#(this.get),
  read .getImm: Opt[imm X] -> {},
  mut  *: X -> this.get,
  read *: read X -> this.get,

  mut .swap(x: X): X,
  mut :=(x: X): Void -> Block#(this.swap(x)),
  mut .set(x: X): Void -> this := x,
  mut <-(f: mut UpdateRef[X]): X -> this.swap(f#(this*)),
  mut .update(f: mut UpdateRef[X]): X -> this <- f,
  }
UpdateRef[X]:{ mut #(x: X): X }
RefImm[X:imm]:Ref[X]{
  read .get: X,
  read *: X -> this.get,
  .getImm(f) -> this.get,
  .getImm -> Opt#(this.get),
  }

Count[N:imm]:RefImm[imm N]{
  mut ++: N,
  mut --: N,
  mut +=(n: N): N,
  mut -=(n: N): N,
  mut *=(n: N): N,
  }
Count:{
  #(n: Int): mut Count[Int] -> this.int(n),
  .int(n: Int): mut Count[Int] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1 },
      -- -> c <- { c' -> c' - 1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    }),
  .uint(n: UInt): mut Count[UInt] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1u },
      -- -> c <- { c' -> c' - 1u },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    })
  }

//---File repr.fear
package base.repr

alias base.Str as Str,
alias base.F as F,//check if we can 'import F[T]'
alias base.Block as Block,
alias base.Void as Void,
alias base.Error as Error,
alias base.Bool as Bool,

FRepr[T:imm]:F[iso T, F[read T,Bool], mut Repr[T]]{
  _x,_inv->Block#
   .letIso x = _x
   .let[mut Repr[T]] res= {mut Repr[T:imm]:{'repr
    read .look[R](f:read F[read T,imm R]): imm R ->f#x,
    mut  .mutate[R](f:read F[mut T,imm R]): imm R -> Block#
      .let[imm R] res={f#x}
      .do{repr.reset}
      .return {res},
    mut  .reset:Void->_inv#x?{.then->Void,.else->Error.msg "AAAH",},
    read .cached[R](f:F[read T,imm R]): imm R ->f#x, //magic
     }}
   .do {res.reset}
   .return {res}
  }








//---File results.fear
package base

Res:{
  #[T](x: T): mut Res[T] -> { .match(m) -> m.a(x), },
  .ok[T,E](x: T): mut Res[T, E] -> { .match(m) -> m.a(x), },
  .err[T,E](x: E): mut Res[T, E] -> { .match(m) -> m.b(x), },
  }
Res[T]:Res[T, Info]
Res[T,E]:Either[T, E]{
  mut  .resMatch[R](m: mut ResMatch[T, E, R]): R -> this.match(m),
  read .resMatch[R](m: mut ResMatch[read T, read E, R]): R -> this.match(m),
  imm  .resMatch[R](m: mut ResMatch[imm T, imm E, R]): R -> this.match(m),

  mut  !: T -> this.resMatch[T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  read !: read T -> this.resMatch[read T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  imm  !: imm T -> this.resMatch[imm T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },

  mut  .map[R](f: mut ResMap[T, E, R]): mut Res[R, E] -> this.match(f),
  read .map[R](f: mut ResMap[read T, read E, R]): mut Res[R, read E] -> this.match(f),
  imm  .map[R](f: mut ResMap[imm T, imm E, R]): mut Res[R, imm E] -> this.match(f),

  mut  .mapErr[R](f: mut ResMapErr[T, E, R]): mut Res[T, R] -> this.match(f),
  read .mapErr[R](f: mut ResMapErr[read T, read E, R]): mut Res[read T, R] -> this.match(f),
  imm  .mapErr[R](f: mut ResMapErr[imm T, imm E, R]): mut Res[imm T, R] -> this.match(f),

  mut  .ok: mut Opt[T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  read .ok: mut Opt[read T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  imm  .ok: iso Opt[imm T] -> this.resMatch[mut Opt[imm T]]{ .ok(x) -> Opt#x, .err(_) -> {} },

  mut  .err: mut Opt[E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  read .err: mut Opt[read E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  imm  .err: iso Opt[imm E] -> this.resMatch[mut Opt[imm E]]{ .ok(_) -> {}, .err(e) -> Opt#e },

  read .isErr: Bool -> this.resMatch{ .err(_) -> True, .ok(_) -> False },
  read .isOk: Bool -> this.resMatch{ .err(_) -> False, .ok(_) -> True },
  }

ResMatch[T,E,R]:EitherMatch[T, E, R]{
  .a(x) -> this.ok(x), .b(x) -> this.err(x),
  mut .ok(x: T): R,
  mut .err(x: E): R
  }
ResMap[T,E,R]:ResMatch[T, E, mut Res[R, E]]{
  mut #(x: T): R,
  .ok(x) -> Res.ok[R, E](this#x),
  .err(x) -> Res.err[R, E](x),
  }
ResMapErr[T,E,R]:ResMatch[T, E, mut Res[T, R]]{
  mut #(x: E): R,
  .ok(x) -> Res.ok[T, R](x),
  .err(x) -> Res.err[T, R](this#x),
  }

//---File strings.fear
package base
Str:Sealed {
  read .str: Str,
  readOnly .size: UInt,
  readOnly .isEmpty: Bool,
  readOnly +(other: readOnly Str): Str,
  readOnly ==(other: readOnly Str): Bool,
  readOnly .toImm: Str,
  readOnly .assertEq(other: readOnly Str): Void,
  }
Stringable: {
  read .str: Str,
  }
_StrInstance:Str {
  .size -> Magic!,
  .isEmpty -> Magic!,
  .str -> Magic!,
  +(other) -> Magic!,
  ==(other) -> Magic!,
  .toImm -> Magic!,
  .assertEq(other) -> Magic!,
  }

_StrHelpers: {
  .assertEq(expected: readOnly Str, actual: readOnly Str): Void ->
    Assert!(expected == actual, "Expected: "+expected+"\nActual: "+actual, {{}}),
  }

StrMap[V]:LinkedLens[Str, V] { k1, k2 -> k1 == k2 }
edLens[K, read V] -> {'next
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k': K): mut Opt[imm V] -> next.keyEq(k, k') ? {.then -> Opt#[imm V]v, .else -> this.get(k')},
    read .get(k': K): mut Opt[read V] -> next.keyEq(k, k') ? {.then -> Opt#[read V]v, .else -> this.get(k')},
    },

  imm .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: MapMapRead[K, V, R]): LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map{res -> fRead#(k, res)},
    },
  mut .map[R](fImm: MapMapImm[K, imm V, imm R], fMut: mut MapMapMut[K, V, R], fRead: read MapMapRead[K, V, R]): mut LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    mut  .get(k: K): mut Opt[R] ->      this.get(k).map{res -> fMut#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map mut OptMap[read V, read R]{res -> fRead#(k, res)},
    },
  read .map[R](fImm: MapMapImm[K, imm V, imm R], fRead: read MapMapRead[K, V, R]): read LinkedLens[K, R] -> {
    .keyEq(k1, k2) -> this.keyEq(k1, k2),
    imm  .get(k: K): mut Opt[imm R] ->  As[mut Opt[imm V]]#(this.get(k)).map{res -> fImm#(k, res)},
    read .get(k: K): mut Opt[read R] -> this.get(k).map{res -> fRead#(k, res)},
    },
  }

MapMapImm[K:imm,V,R]:{ #(k: K, v: imm V): R }
MapMapMut[K:imm,V,R]:{ mut #(k: K, v: V): R }
MapMapRead[K:imm,V,R]:{ read #(k: K, v: read V): read R }

//---File nums.fear
package base

Int:Sealed,_MathOps[imm Int],_IntOps[imm Int]{
  readOnly .uint: UInt,
  readOnly .float: Float,
  // not Stringable due to limitations of the Java codegen target
  read .str: Str,
  }
UInt:Sealed,_MathOps[imm UInt],_IntOps[imm UInt]{
  readOnly .int: Int,
  readOnly .float: Float,
  // not Stringable due to limitations of the Java codegen target
  read .str: Str,
  }
Float:Sealed,_MathOps[imm Float]{
  readOnly .int: Int,
  readOnly .uint: UInt,
  readOnly .round: Int,
  readOnly .ceil: Int,
  readOnly .floor: Int,
  readOnly **(n: readOnly Float): Float, // pow
  readOnly .isNaN: Bool,
  readOnly .isInfinite: Bool,
  readOnly .isPosInfinity: Bool,
  readOnly .isNegInfinity: Bool,
  // not Stringable due to limitations of the Java codegen target
  read .str: Str,
  }

_MathOps[T]:Sealed{
  readOnly .toImm: T,
  readOnly +(n: readOnly T): T,
  readOnly -(n: readOnly T): T,
  readOnly *(n: readOnly T): T,
  readOnly /(n: readOnly T): T,
  readOnly %(n: readOnly T): T,
  readOnly .abs: T,

  // Comparisons
  readOnly >(n: readOnly T): Bool,
  readOnly <(n: readOnly T): Bool,
  readOnly >=(n: readOnly T): Bool,
  readOnly <=(n: readOnly T): Bool,
  readOnly ==(n: readOnly T): Bool,
  }
_IntOps[T]:Sealed{
  // bitwise
  readOnly >>(n: readOnly T): T,
  readOnly <<(n: readOnly T): T,
  readOnly ^(n: readOnly T): T,
  readOnly &(n: readOnly T): T,
  readOnly |(n: readOnly T): T,

  readOnly **(n: readOnly UInt): T, // pow
  }

// Fake concrete type for all numbers. The real implementation is generated at code-gen.
_IntInstance:Int{
  .uint -> Magic!,
  .float -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,

  // bitwise
  >>(n) -> Magic!,
  <<(n) -> Magic!,
  ^(n) -> Magic!,
  &(n) -> Magic!,
  |(n) -> Magic!,

  // Comparisons
  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }
_UIntInstance:UInt{
  .int -> Magic!,
  .float -> Magic!,
  .str -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,

  // bitwise
  >>(n) -> Magic!,
  <<(n) -> Magic!,
  ^(n) -> Magic!,
  &(n) -> Magic!,
  |(n) -> Magic!,

  // Comparisons
  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }
_FloatInstance:Float{
  .int -> Magic!,
  .uint -> Magic!,
  .str -> Magic!,
  .round -> Magic!,
  .ceil -> Magic!,
  .floor -> Magic!,
  .isNaN -> Magic!,
  .isInfinite -> Magic!,
  .isPosInfinity -> Magic!,
  .isNegInfinity -> Magic!,
  +(n) -> Magic!,
  -(n) -> Magic!,
  *(n) -> Magic!,
  /(n) -> Magic!,
  %(n) -> Magic!,
  **(n) -> Magic!,
  .abs -> Magic!,
  .toImm -> Magic!,
  // Comparisons
  >n -> Magic!,
  <n -> Magic!,
  >=n -> Magic!,
  <=n -> Magic!,
  ==n -> Magic!,
  }

//---File optionals.fear
package base

Opt:{ #[T](x: T): mut Opt[T] -> {
   .match(m) -> m.some(x),
//  mut .match[R](m: mut OptMatch[T, R]): R -> m.some(x),
//  read .match[R](m: mut OptMatch[read T, R]): R -> m.some(x),
//  // imm case is needed because the read one will return read E even if E is imm
//  imm  .match[R](m: mut OptMatch[T, R]): R -> m.some(x),
  }}
Opt[T]:Extensible[Opt[T]]{
  .self -> this,
  mut  .match[R](m: mut OptMatch[T, R]): R -> m.empty,
  read .match[R](m: mut OptMatch[read T, R]): R -> m.empty,
  imm  .match[R](m: mut OptMatch[imm T, R]): R -> m.empty,

  mut  !: T -> this.match[T](mut OptMatch[T, T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  read !: read T -> this.match[read T](mut OptMatch[read T, read T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),
  imm  !: imm T -> this.match[imm T](mut OptMatch[imm T, imm T]{ .some(x) -> x, .empty -> Error.msg "Opt was empty" }),

  mut .map[R](f: mut OptMap[T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  read .map[R](f: mut OptMap[read T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),
  imm  .map[R](f: mut OptMap[imm T, R]): mut Opt[R] -> this.match[mut Opt[R]](f),

//  mut |(alt: T): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt
//    }),
//  read |(alt: read T): read T -> this.match[read T](mut OptMatch[read T, read T]{
//    .some(x) -> x,
//    .empty -> alt
//    }),
//  imm  |(alt: T): T -> this.match[T](mut OptMatch[T, T]{
//      .some(x) -> x,
//      .empty -> alt
//      }),
//
//  mut  ||(alt: mut OptOrElse[T]): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//  read ||(alt: mut OptOrElse[read T]): read T -> this.match[read T](mut OptMatch[read T, read T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//  imm ||(alt: mut OptOrElse[T]): T -> this.match[T](mut OptMatch[T, T]{
//    .some(x) -> x,
//    .empty -> alt#
//    }),
//
//  mut .or(f: mut OptOrElse[mut Opt[T]]): mut Opt[T] -> this.match[mut Opt[T]](mut OptMatch[T, mut Opt[T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
////   TODO: this is the method that breaks the adapter ok check for imm Opt[read T] < imm Opt[imm T]
//  read .or(f: mut OptOrElse[read Opt[T]]): read Opt[T] -> this.match[read Opt[T]](mut OptMatch[read T, read Opt[T]]{
//    .some(x) -> this,
//    .empty -> f#
//    }),
//  imm .or(f: mut OptOrElse[Opt[T]]): Opt[T] -> this.match[Opt[T]](mut OptMatch[T, Opt[T]]{
//      .some(x) -> this,
//      .empty -> f#
//      }),

  read .isEmpty: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> True, .some(_) -> False }),
  read .isSome: Bool -> this.match[Bool](mut OptMatch[read T, Bool]{ .empty -> False, .some(_) -> True }),

  mut  .flow: mut Flow[T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  imm  .flow: mut Flow[imm T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  read .flow: mut Flow[read T] -> this.match{
    .empty -> Flow#,
    .some(x) -> Flow#(x)
    },
  }

OptMatch[T,R]:{ mut .some(x: T): R, mut .empty: R }
OptOrElse[R]:{ mut #: R }
OptMap[T,R]:OptMatch[T, mut Opt[R]]{
  mut #(t: T): R,
  .some(x) -> Opt#(this#x),
  .empty -> {}
  }

// TODO: proof of concept for extension methods
OptOrElseExt[T]:Extension[mut Opt[T], T]{
  mut .alt: T,
  #(opt) -> opt.match{ .some(x) -> x, .empty -> this.alt }
  }

//---File pkg.fear
package base
alias base.iter.Iter as Iter,

//---File ref.fear
package base

Ref:{
  #[X](x: X): mut Ref[X] -> Magic!,
  readOnly #[X](x: imm X): mut RefImm[imm X] -> Ref.ofImm x,
  .ofImm[X](x: imm X): mut RefImm[imm X] -> Let#{
    .var -> Ref#(Ice[imm X]{x}),
      .in(ref) -> {
         mut  .get: imm X -> ref.get.get,
         read .get: imm X -> ref.get.get,
         .swap(newX) -> ref.swap(Ice[imm X]{newX}).get,
         }
      }
  }
Ref[X:imm,mut,read]:Sealed{
  mut  .get: X,
  read .get: read X,
  // TODO: this will be unneeded if we add read/imm
  read .getImm(f: mut Freezer[read X, imm X]): imm X -> f#(this.get),
  read .getImm: Opt[imm X] -> {},
  mut  *: X -> this.get,
  read *: read X -> this.get,

  mut .swap(x: X): X,
  mut :=(x: X): Void -> Block#(this.swap(x)),
  mut .set(x: X): Void -> this := x,
  mut <-(f: mut UpdateRef[X]): X -> this.swap(f#(this*)),
  mut .update(f: mut UpdateRef[X]): X -> this <- f,
  }
UpdateRef[X]:{ mut #(x: X): X }
RefImm[X:imm]:Ref[X]{
  read .get: X,
  read *: X -> this.get,
  .getImm(f) -> this.get,
  .getImm -> Opt#(this.get),
  }

Count[N:imm]:RefImm[imm N]{
  mut ++: N,
  mut --: N,
  mut +=(n: N): N,
  mut -=(n: N): N,
  mut *=(n: N): N,
  }
Count:{
  #(n: Int): mut Count[Int] -> this.int(n),
  .int(n: Int): mut Count[Int] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1 },
      -- -> c <- { c' -> c' - 1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    }),
  .uint(n: UInt): mut Count[UInt] -> Let#({
    .var -> Ref.ofImm n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1u },
      -- -> c <- { c' -> c' - 1u },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    })
  }

//---File repr.fear
package base.repr

alias base.Str as Str,
alias base.F as F,//check if we can 'import F[T]'
alias base.Block as Block,
alias base.Void as Void,
alias base.Error as Error,
alias base.Bool as Bool,

FRepr[T:imm]:F[iso T, F[read T,Bool], mut Repr[T]]{
  _x,_inv->Block#
   .letIso x = _x
   .let[mut Repr[T]] res= {mut Repr[T:imm]:{'repr
    read .look[R](f:read F[read T,imm R]): imm R ->f#x,
    mut  .mutate[R](f:read F[mut T,imm R]): imm R -> Block#
      .let[imm R] res={f#x}
      .do{repr.reset}
      .return {res},
    mut  .reset:Void->_inv#x?{.then->Void,.else->Error.msg "AAAH",},
    read .cached[R](f:F[read T,imm R]): imm R ->f#x, //magic
    //read .cached[R](f:RepeatableF[read T,imm R]): imm R ->f#x, //magic
    //read .derived[R](f:F[read T,imm R]): imm R ->f#x, //magic
     }}
   .do {res.reset}
   .return {res}
  }

//TODO: add .repr to block with .invariant?
//RepeatableF could be a magic type that give extra type errors if it captures badly

  //489 errors: comma after methods
  // colon (:) for inline declarations, (:) after implements
  // missing return type


  //inference bug: why Block#.let[imm R] res={f#x} .do{repr.reset} .return {res}, requires imm R



  //FRepr[T:imm]:F[iso T, List[F[read T,Bool]], mut Repr[T]]{

//---File results.fear
package base

Res:{
  #[T](x: T): mut Res[T] -> { .match(m) -> m.a(x), },
  .ok[T,E](x: T): mut Res[T, E] -> { .match(m) -> m.a(x), },
  .err[T,E](x: E): mut Res[T, E] -> { .match(m) -> m.b(x), },
  }
Res[T]:Res[T, Info]
Res[T,E]:Either[T, E]{
  mut  .resMatch[R](m: mut ResMatch[T, E, R]): R -> this.match(m),
  read .resMatch[R](m: mut ResMatch[read T, read E, R]): R -> this.match(m),
  imm  .resMatch[R](m: mut ResMatch[imm T, imm E, R]): R -> this.match(m),

  mut  !: T -> this.resMatch[T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  read !: read T -> this.resMatch[read T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },
  imm  !: imm T -> this.resMatch[imm T]{ .ok(x) -> x, .err(_) -> Error.msg "Res was not ok" },

  mut  .map[R](f: mut ResMap[T, E, R]): mut Res[R, E] -> this.match(f),
  read .map[R](f: mut ResMap[read T, read E, R]): mut Res[R, read E] -> this.match(f),
  imm  .map[R](f: mut ResMap[imm T, imm E, R]): mut Res[R, imm E] -> this.match(f),

  mut  .mapErr[R](f: mut ResMapErr[T, E, R]): mut Res[T, R] -> this.match(f),
  read .mapErr[R](f: mut ResMapErr[read T, read E, R]): mut Res[read T, R] -> this.match(f),
  imm  .mapErr[R](f: mut ResMapErr[imm T, imm E, R]): mut Res[imm T, R] -> this.match(f),

  mut  .ok: mut Opt[T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  read .ok: mut Opt[read T] -> this.resMatch{ .ok(x) -> Opt#x, .err(_) -> {} },
  imm  .ok: iso Opt[imm T] -> this.resMatch[mut Opt[imm T]]{ .ok(x) -> Opt#x, .err(_) -> {} },

  mut  .err: mut Opt[E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  read .err: mut Opt[read E] -> this.resMatch{ .ok(_) -> {}, .err(e) -> Opt#e },
  imm  .err: iso Opt[imm E] -> this.resMatch[mut Opt[imm E]]{ .ok(_) -> {}, .err(e) -> Opt#e },

  read .isErr: Bool -> this.resMatch{ .err(_) -> True, .ok(_) -> False },
  read .isOk: Bool -> this.resMatch{ .err(_) -> False, .ok(_) -> True },
  }

ResMatch[T,E,R]:EitherMatch[T, E, R]{
  .a(x) -> this.ok(x), .b(x) -> this.err(x),
  mut .ok(x: T): R,
  mut .err(x: E): R
  }
ResMap[T,E,R]:ResMatch[T, E, mut Res[R, E]]{
  mut #(x: T): R,
  .ok(x) -> Res.ok[R, E](this#x),
  .err(x) -> Res.err[R, E](x),
  }
ResMapErr[T,E,R]:ResMatch[T, E, mut Res[T, R]]{
  mut #(x: E): R,
  .ok(x) -> Res.ok[T, R](x),
  .err(x) -> Res.err[T, R](this#x),
  }

//---File strings.fear
package base
Str:Sealed {
  // Str is not Stringable due to limitations of the Java codegen target
  read .str: Str,
  readOnly .size: UInt,
  readOnly .isEmpty: Bool,
  readOnly +(other: readOnly Str): Str,
  readOnly ==(other: readOnly Str): Bool,
  readOnly .toImm: Str,
  readOnly .assertEq(other: readOnly Str): Void,
  }
Stringable: {
  read .str: Str,
  }
_StrInstance:Str {
  .size -> Magic!,
  .isEmpty -> Magic!,
  .str -> Magic!,
  +(other) -> Magic!,
  ==(other) -> Magic!,
  .toImm -> Magic!,
  .assertEq(other) -> Magic!,
  }

_StrHelpers: {
  .assertEq(expected: readOnly Str, actual: readOnly Str): Void ->
    Assert!(expected == actual, "Expected: "+expected+"\nActual: "+actual, {{}}),
  }

StrMap[V]:LinkedLens[Str, V] { k1, k2 -> k1 == k2 }
