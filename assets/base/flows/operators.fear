package base.flows

// I could have .step with a read sink (so we know that sink operation can be parallelised) _and_ a .step with a mut sink
// which must be sequential. However, this adds implementation burden for people making flowable data structures and introduces
// new sources of runtime exceptions (i.e. accidentally calling the non .seq and it throwing because it would have to be
// unimplemented). Because _Sink/2 is a private trait, we can just manually make sure that a _Sink that would be unsafe
// to parallelise never runs in parallel. This should be easy because basically all parallel implementations of _Sink
// will be Magic!.

FlowOp[E]: {
  mut .step(sink: mut _Sink[E]): Void,
  mut .stop: Void,
  mut .isRunning: Bool,
  mut .for(downstream: mut _Sink[E]): Void -> Block#
    .loop {Block#
      .if {this.isRunning.not} .return {Block#(downstream.stop, ControlFlow.break)}
      .do {this.step(downstream)}
      .return {ControlFlow.continue}
      }
    .return {Void},
  mut .isFinite: Bool -> True,
  /// Mutates the data source for this flow to be a sub-section of the original input. This is useful for fork-join
  /// data-parallelism. Returning an empty optional either means that there is no data left to split, the
  /// data source does not think splitting further would be beneficial for parallelism, or that the data source
  /// does not wish to be run in data parallel. On the other side, implementing this method does not guarantee that
  /// this flow operator will be run in data parallel. That decision is up to the compiler and runtime.
  mut .split: mut Opt[mut FlowOp[E]] -> {},
  read .canSplit: Bool -> False,
  }


_Sink: {
  #[T](s: mut _Sink[T]): mut _Sink[T] -> s,
  }
_Sink[T]: {
  mut #(x: T): Void,
  mut .pushError(info: Info): Void,
  mut .stop: Void,
  }

// IMPORTANT NOTE: REUSE SINK OBJECTS! THE IDENTITY IS IMPORTANT FOR WHEN THEY ARE RAN IN PARALLEL!!!!!

_Filter: {
  #[E](sinkFactory: _Sink, upstream: mut FlowOp[E], predicate: read F[E, Bool]): mut FlowOp[E] -> Block#
    .var[mut Opt[mut _Sink[E]]] sink = {{}}
    .let[mut MF[mut _Sink[E],mut MF[mut _Sink[E]]]] newSink = {{downstream -> {
      sinkFactory#[E]{
        #(e) -> predicate#e ? {.then -> downstream#e, .else -> {}},
        .stop -> downstream.stop,
        .pushError(info) -> downstream.pushError(info),
        }
      }}}
    .return{{
      .step(downstream) ->
        this.run(sink, newSink#downstream, {sink' -> upstream.step(sink')}),
      .for(downstream) ->
        this.run(sink, newSink#downstream, {sink' -> upstream.for(sink')}),
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      .split -> upstream.split.map{right -> this#(sinkFactory, right, predicate)},
      }},
  .run[E](
    sink: mut Var[mut Opt[mut _Sink[E]]],
    newSink: mut MF[mut _Sink[E]],
    task: mut MF[mut _Sink[E],Void]
    ): Void ->
    sink.get.match{
      .some(sink') -> task#sink',
      .empty -> Block#
        .let[mut _Sink[E]] sink' = {newSink#}
        .do {sink.set(Opts#sink')}
        .return {task#sink'},
      },
  }
// TODO: ^ use the `this.run` pattern in the other operators to reduce code reuse.
_Map: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, R]): mut FlowOp[R] ->
    this#[_EmptyCtx,E,R](sinkFactory, upstream, iso _EmptyCtx, {_,e -> f#e}),
  // It would be unsound to call this with a non-iso `c` if this is run in parallel.
  // It's okay here because the public API of this library requires that `c` is iso.
  #[C,E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], ctx: iso ToIso[C], f: read F[iso C, E, R]): mut FlowOp[R] -> Block#
    .openIso ctx' = ctx
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return  {{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#(ctx'.iso.self, e)),
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> downstream.stop,
            #(e) -> downstream#(f#(ctx'.iso.self, e)),
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> upstream.isRunning,
      .split -> upstream.split.map{right -> this#[C,E,R](sinkFactory, right, ctx'.iso, f)},
    }}
  }
_FlatMap: {
  #[E,R](sinkFactory: _Sink, upstream: mut FlowOp[E], f: read F[E, mut Flow[R]]): mut FlowOp[R] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[E]]]] sink = {Vars#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .let nestedOp = {f#e.unwrapOp(mut _UnwrapFlowToken)}
              .return {nestedOp.for{
                #(e') -> op.isRunning ? {.then -> downstream#e', .else -> nestedOp.stop},
                .stop -> {},
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[E]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .let nestedOp = {f#e.unwrapOp(mut _UnwrapFlowToken)}
              .return {nestedOp.for{
                #(e') -> op.isRunning ? {.then -> downstream#e', .else -> nestedOp.stop},
                .stop -> {},
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> isRunning*,
      .split -> upstream.split.map{right -> this#(sinkFactory, right, f)},
      }}
  }

// TODO: I'm still not 100% sure .with/1 is safe in parallel
_With: {
  #[A,B](sinkFactory: _Sink, upstream: mut FlowOp[A], other: mut FlowOp[B]): mut FlowOp[mut Pair[A,B]] -> Block#
    .let[mut Var[Bool]] isRunning = {Vars#[Bool]True}
    .let[mut Var[mut Opt[mut _Sink[A]]]] sink = {Vars#{}}
    .return{{'op
      .step(downstream) -> sink.get.match{
        .some(sink') -> upstream.step(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[A]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .return {other.step{
                #(e') -> op.isRunning ? {.then -> downstream#{.a -> e, .b -> e'}, .else -> other.stop},
                .stop -> op.stop,
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.step(sink.get!)
          )
        },
      .for(downstream) -> sink.get.match{
        .some(sink') -> upstream.for(sink'),
        .empty -> Block#(
          sink := (Opts#(sinkFactory#[A]{
            .stop -> Block#(isRunning := False, downstream.stop),
            #(e) -> Block#
              .return {other.step{
                #(e') -> op.isRunning ? {.then -> downstream#{.a -> e, .b -> e'}, .else -> other.stop},
                .stop -> op.stop,
                .pushError(info) -> downstream.pushError(info),
                }},
            .pushError(info) -> downstream.pushError(info),
            })),
          upstream.for(sink.get!)
          )
        },
      .stop -> upstream.stop,
      .isRunning -> isRunning*,
      .split -> Block#
        .if {upstream.canSplit.not} .return {{}}
        .if {other.canSplit.not} .return {{}}
        .return {Opts#(this#(sinkFactory, upstream.split!, other.split!))},
      }}
  }
