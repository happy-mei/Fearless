package base.flows
alias base.Todo as Todo,

Flow: Sealed, _FlowExtensions, _FlowConverters{
  #[E]: mut Flow[E] -> mut EmptyFlow[E],
  #[E](e: E): mut Flow[E] -> _SeqFlow#[E](e),
  #[E](e1: E, e2: E): mut Flow[E] -> List#(e1, e2).flow,
  #[E](e1: E, e2: E, e3: E): mut Flow[E] -> List#(e1, e2, e3).flow,
  #[E](e1: E, e2: E, e3: E, e4: E): mut Flow[E] -> List#(e1, e2, e3, e4).flow,

  // These fromOp calls will always be sequential. Only flows made from specific standard library types
  // could have a parallel constructor.
  .fromOp[E](source: mut FlowOp[E]): mut Flow[E] -> _SeqFlow.fromOp(source, {}),
  .fromOp[E](source: mut FlowOp[E], size: Nat): mut Flow[E] -> _SeqFlow.fromOp(source, Opts#size),

  // This variant of fromOp asks the compiler to emit code that collects the source into an intermediary list to
  // avoid any concurrent modification issues if they would be possible during the execution of the flow.
  .fromMutSource[E](source: mut FlowOp[E]): mut Flow[E] -> _MutSourceCollection[E]#source,
  .fromMutSource[E](source: mut FlowOp[E], size: Nat): mut Flow[E] -> _MutSourceCollection[E]#source,
  }

Flow[E]: Sealed, Extensible[Flow[E]], _NonTerminalOps[E], _TerminalOps[E]{
  .self -> this,
  mut .let[DR,R](x: read F[mut MF[mut Flow[E]],DR], cont: mut Continuation[DR,mut Flow[E],R]): R -> Block#
    .let duplicator = {_LazyFlowDuplicators#this}
    .let splitResult = {x#duplicator}
    .let[mut Flow[E]] selfFlow = {duplicator.collected.match{
      .some(collected) -> collected.flow,
      .empty -> this,
      }}
    .return {cont#(splitResult, selfFlow)},
  mut .join(j: Joinable[E]): E -> j.join(this),
  mut .unwrapOp(unwrap: mut _UnwrapFlowToken): mut FlowOp[E],
  mut .only: mut Action[E] -> {res -> Block#
    .let found = {this.limit(2).list}
    .if {found.size == 1} .return {res.ok(found.get(0))}
    .return {res.info(Infos.msg("Expected exactly one element, found " + (found.size.str)))}
    },
  }
_UnwrapFlowToken: {}

_NonTerminalOps[E]: {
  mut .filter(predicate: read F[E, Bool]): mut Flow[E],
  mut .map[R](f: read F[E, R]): mut Flow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R],
  /// Combine this flow with another flow, producing a flow of pairs. The resulting flow will stop when either of the source
  /// flows stop.
  mut .with[EB](other: mut Flow[EB]): mut Flow[mut Pair[E,EB]],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R],

  mut .limit(n: Nat): mut Flow[E],

  // TODO: this can keep size if it is known
  mut .scan[S:imm](acc: imm S, f: read F[S,E,S]): mut Flow[imm S] -> this.actor[mut Var[imm S], imm S](Var#[imm S]acc, {downstream, acc', e -> Block#(
    acc' := (f#(acc'.get, e)),
    downstream#(acc'.get),
    ActorRes.continue
    )}),
  }
_TerminalOps[E]: Sealed{
  // has to be magic because of strong exception safety (flows are mut and thus cannot be in a Try)
//  mut .action[R:iso,imm,mut,mutH,read,readH](terminalOp: read F[mut Flow[E],R]): mut Action[R] -> Todo!,

  mut .first: mut Opt[E],
  mut .findMap[R](f: read F[E, mut Opt[R]]): mut Opt[R],
  mut .fold[S](acc: S, f: read F[S,E,S]): S,
  mut .size: Nat,

  mut .find(predicate: read F[E, Bool]): mut Opt[E] -> this.findMap{e -> predicate#e ? {.then -> Opts#e, .else -> {}}},
  mut .any(predicate: read F[E, Bool]): Bool -> this
    .findMap{e -> predicate#e ? {.then -> Opts#True, .else -> {}}}
    .isSome,
  mut .all(predicate: read F[E, Bool]): Bool -> this
    .findMap{e -> predicate#e ? {.then -> {}, .else -> Opts#False}}
    .isEmpty,
  mut .for(f: read F[E, Void]): Void -> this.fold(Void, {_, e -> f#e}),
  mut .list: mut List[E] -> this.fold(List#[E], {acc, e -> Block#(acc.add(e), acc)}),
  mut .max(compare: read F[E, E, Ordering]): mut Opt[E] -> this.fold[mut Opt[E]]({}, {max, b -> max.match{
    .empty -> Opts#b,
    .some(a) -> compare#(a, b).match{
      .less -> Opts#b,
      .equal -> max,
      .greater -> max,
      }
    }})
    }

// TODO: move all of these extension methods onto the data-types, i.e. myflow#"," to join with "," or myflow#(Int.sum) for summing
_FlowExtensions: {
  .str(separator: Str): mut Extension[mut Flow[Str], Str] -> {flow -> flow.fold[Str]("", {acc, str -> acc.isEmpty ? {
    .then -> acc + str,
    .else -> acc + separator + str,
    }})},

  .sum: mut Extension[mut Flow[Int], Int] -> {flow -> flow.fold[Int](+0, {acc, e -> acc + e})},
  .uSum: mut Extension[mut Flow[Nat], Nat] -> {flow -> flow.fold[Nat](0, {acc, e -> acc + e})},
  .fSum: mut Extension[mut Flow[Float], Float] -> {flow -> flow.fold[Float](0.0, {acc, e -> acc + e})},

  .enumerate[E:imm]: mut Extension[mut Flow[E], mut Flow[Enumerated[E]]] -> {flow ->
    flow.actor[mut Count[Nat],Enumerated[E]](Count.nat(0), {downstream, i, e ->
      Block#(downstream#(_Enumerateds#(i++, e)), {})
      })
    },
  }

EmptyFlow[E]: Flow[E]{
  .filter(p) -> this,
  mut .with[EB](other: mut Flow[EB]): mut Flow[mut Pair[E,EB]] -> mut EmptyFlow[mut Pair[E,EB]],
  mut .map[R](f: read F[E, R]): mut Flow[R] -> mut EmptyFlow[R],
  mut .flatMap[R](f: read F[E, mut Flow[R]]): mut Flow[R] -> mut EmptyFlow[R],
  mut .actor[S,R](state: iso S, f: read ActorImpl[S,E,R]): mut Flow[imm R] -> mut EmptyFlow[imm R],
  mut .actorMut[S,R](state: iso S, f: read ActorImplMut[S,E,R]): mut Flow[R] -> mut EmptyFlow[R],
  .limit(_) -> this,
  .first -> {},
  .findMap(_) -> {},
  .find(_) -> {},
  .any(p) -> False,
  .all(p) -> False,
  .fold(acc, _) -> acc,
  .size -> 0,
  .unwrapOp(_) -> {
    .step(_) -> {},
    .stop -> {},
    .isRunning -> False,
    },
  }

TerminalOnInfiniteError: { #: Info -> Infos.msg "Terminal operators cannot be called on infinite flows. Use an operation like .limit(5) to bound the flow." }

_LimitSize: {#(n: Nat, size: Opt[Nat]): Opt[Nat] ->
  size.map{beforeLimit ->
    beforeLimit > n ? { .then -> n, .else -> beforeLimit, }
    }
  }

_Enumerateds: {#[E:imm](i: Nat, e: E): Enumerated[E] -> Enumerated[E:imm]: {
  .i: Nat -> i,
  .e: E -> e,
  }}

Pair[A,B]: {mut .a: A, mut .b: B}
