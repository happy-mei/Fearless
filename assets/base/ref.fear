package base

Ref:{
  #[X](x: X): mut Ref[X] -> Block#
    .let[mut _MagicRefImpl[X]] inner = {_MagicRefImpl#x}
    .return {{
      .get -> inner.get,
      .swap(x') -> inner.swap(x'),
      }},
  }
Ref[X:imm,mut,read]: Sealed{
  mut  .get: X,
  read .get: read X,
  // TODO: this will be unneeded if we add read/imm
  read .getImm(f: mut Freezer[read X, imm X]): imm X -> f#(this.get),
  read .getImm: Opt[imm X] -> {},
  mut  *: X -> this.get,
  read *: read X -> this.get,

  mut .swap(x: X): X,
  mut :=(x: X): Void -> Block#(this.swap(x)),
  mut .set(x: X): Void -> this := x,
  mut <-(f: mut UpdateRef[X]): X -> this.swap(f#(this*)),
  mut .update(f: mut UpdateRef[X]): X -> this <- f,
  }
UpdateRef[X]: { mut #(x: X): X }

Count[N:imm]: Ref[N]{
  mut ++: N,
  mut --: N,
  mut +=(n: N): N,
  mut -=(n: N): N,
  mut *=(n: N): N,
  }
Count:{
  #(n: Int): mut Count[Int] -> this.int(n),
  .int(n: Int): mut Count[Int] -> Let#({
    .var -> Ref#n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1 },
      -- -> c <- { c' -> c' - 1 },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    }),
  .uint(n: UInt): mut Count[UInt] -> Let#({
    .var -> Ref#n,
    .in(c) -> {
      .get -> c.get,
      .swap(x) -> c.swap(x),
      ++ -> c <- { c' -> c' + 1u },
      -- -> c <- { c' -> c' - 1u },
      +=(n2) -> c <- { c' -> c' + n2 },
      -=(n2) -> c <- { c' -> c' - n2 },
      *=(n2) -> c <- { c' -> c' * n2 },
      }
    })
  }

// Ref as defined in the formal reduction of Fearless.
// We capture this in the richer Ref.
_MagicRefImpl: {#[X](x: X): mut _MagicRefImpl[X] -> Magic!}
_MagicRefImpl[X]: {
  mut  .get: X,
  read .get: read X,
  mut .swap(x: X): X,
  }
