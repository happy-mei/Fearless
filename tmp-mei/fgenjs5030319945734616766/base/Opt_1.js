import { base$$_Opt_1 } from "../base/_Opt_1.js";
import * as rt from "../rt/main.js";

export class base$$Opt_1 extends base$$_Opt_1 {
  static $self = new base$$Opt_1();

  $exclamation$imm() {
  return base$$Opt_1.$exclamation$imm$fun(this);
}


$exclamation$read() {
  return base$$Opt_1.$exclamation$read$fun(this);
}


$exclamation$mut() {
  return base$$Opt_1.$exclamation$mut$fun(this);
}


$pipe$pipe$imm($default) {
  return base$$Opt_1.$pipe$pipe$imm$fun($default, this);
}


$pipe$pipe$read($default) {
  return base$$Opt_1.$pipe$pipe$read$fun($default, this);
}


$pipe$pipe$mut($default) {
  return base$$Opt_1.$pipe$pipe$mut$fun($default, this);
}


$pipe$imm($default) {
  return base$$Opt_1.$pipe$imm$fun($default, this);
}


$pipe$read($default) {
  return base$$Opt_1.$pipe$read$fun($default, this);
}


$pipe$mut($default) {
  return base$$Opt_1.$pipe$mut$fun($default, this);
}


isEmpty$read() {
  return base$$Opt_1.isEmpty$read$fun(this);
}


ifEmpty$read(f_m$) {
  return base$$Opt_1.ifEmpty$read$fun(f_m$, this);
}


flatMap$imm(f_m$) {
  return base$$Opt_1.flatMap$imm$fun(f_m$, this);
}


flatMap$read(f_m$) {
  return base$$Opt_1.flatMap$read$fun(f_m$, this);
}


flatMap$mut(f_m$) {
  return base$$Opt_1.flatMap$mut$fun(f_m$, this);
}


match$imm(m_m$) {
  return base$$Opt_1.match$imm$fun(m_m$, this);
}


match$read(m_m$) {
  return base$$Opt_1.match$read$fun(m_m$, this);
}


match$mut(m_m$) {
  return base$$Opt_1.match$mut$fun(m_m$, this);
}


flow$imm() {
  return base$$Opt_1.flow$imm$fun(this);
}


flow$read() {
  return base$$Opt_1.flow$read$fun(this);
}


flow$mut() {
  return base$$Opt_1.flow$mut$fun(this);
}


map$imm(f_m$) {
  return base$$Opt_1.map$imm$fun(f_m$, this);
}


map$read(f_m$) {
  return base$$Opt_1.map$read$fun(f_m$, this);
}


map$mut(f_m$) {
  return base$$Opt_1.map$mut$fun(f_m$, this);
}


isSome$read() {
  return base$$Opt_1.isSome$read$fun(this);
}


ifSome$imm(f_m$) {
  return base$$Opt_1.ifSome$imm$fun(f_m$, this);
}


ifSome$read(f_m$) {
  return base$$Opt_1.ifSome$read$fun(f_m$, this);
}


ifSome$mut(f_m$) {
  return base$$Opt_1.ifSome$mut$fun(f_m$, this);
}


imm$imm() {
  return base$$Opt_1.imm$imm$fun(this);
}

  static match$mut$fun(m_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static match$read$fun(m_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static match$imm$fun(m_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static map$mut$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static map$read$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static map$imm$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flatMap$mut$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flatMap$read$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flatMap$imm$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$pipe$mut$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$pipe$read$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$pipe$imm$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$mut$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$read$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $pipe$imm$fun($default, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $exclamation$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $exclamation$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static $exclamation$imm$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flow$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flow$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flow$imm$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static ifSome$mut$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static ifSome$read$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static ifSome$imm$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static isEmpty$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static isSome$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static imm$imm$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static ifEmpty$read$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

}
