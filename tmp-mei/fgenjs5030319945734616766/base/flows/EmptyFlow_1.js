import { base$$flows$$Flow_1 } from "../../base/flows/Flow_1.js";
import * as rt from "../rt/main.js";

export class base$$flows$$EmptyFlow_1 extends base$$flows$$Flow_1 {
  static $self = new base$$flows$$EmptyFlow_1();

  forEffect$mut(f_m$) {
  return base$$flows$$_TerminalOps_1.forEffect$mut$fun(f_m$, this);
}


peek$mut(f_m$) {
  return base$$flows$$_NonTerminalOps_1.peek$mut$fun(f_m$, this);
}


peek$mut(ctx_m$, f_m$) {
  return base$$flows$$_NonTerminalOps_1.peek$mut$fun(ctx_m$, f_m$, this);
}


actorMut$mut(state_m$, f_m$) {
  return base$$flows$$EmptyFlow_1.actorMut$mut$fun(state_m$, f_m$, this);
}


self$mut() {
  return base$$flows$$Flow_1.self$mut$fun(this);
}


self$read() {
  return base$$flows$$Flow_1.self$read$fun(this);
}


self$imm() {
  return base$$flows$$Flow_1.self$imm$fun(this);
}


let$mut(x_m$, cont_m$) {
  return base$$flows$$Flow_1.let$mut$fun(x_m$, cont_m$, this);
}


assumeFinite$mut() {
  return base$$flows$$EmptyFlow_1.assumeFinite$mut$fun(this);
}


actor$mut(state_m$, f_m$) {
  return base$$flows$$EmptyFlow_1.actor$mut$fun(state_m$, f_m$, this);
}


first$mut() {
  return base$$flows$$EmptyFlow_1.first$mut$fun(this);
}


list$mut() {
  return base$$flows$$_TerminalOps_1.list$mut$fun(this);
}


all$mut(p_m$) {
  return base$$flows$$EmptyFlow_1.all$mut$fun(p_m$, this);
}


filter$mut(p_m$) {
  return base$$flows$$EmptyFlow_1.filter$mut$fun(p_m$, this);
}


none$mut(predicate_m$) {
  return base$$flows$$_TerminalOps_1.none$mut$fun(predicate_m$, this);
}


flatMap$mut(f_m$) {
  return base$$flows$$EmptyFlow_1.flatMap$mut$fun(f_m$, this);
}


opt$mut() {
  return base$$flows$$Flow_1.opt$mut$fun(this);
}


get$mut() {
  return base$$flows$$Flow_1.get$mut$fun(this);
}


count$mut() {
  return base$$flows$$EmptyFlow_1.count$mut$fun(this);
}


findMap$mut(fear2199$_m$) {
  return base$$flows$$EmptyFlow_1.findMap$mut$fun(fear2199$_m$, this);
}


join$mut(j_m$) {
  return base$$flows$$Flow_1.join$mut$fun(j_m$, this);
}


last$mut() {
  return base$$flows$$_TerminalOps_1.last$mut$fun(this);
}


unwrapOp$mut(fear2200$_m$) {
  return base$$flows$$EmptyFlow_1.unwrapOp$mut$fun(fear2200$_m$, this);
}


mapFilter$mut(f_m$) {
  return base$$flows$$_NonTerminalOps_1.mapFilter$mut$fun(f_m$, this);
}


fold$mut(acc_m$, fear2201$_m$) {
  return base$$flows$$EmptyFlow_1.fold$mut$fun(acc_m$, fear2201$_m$, this);
}


only$mut() {
  return base$$flows$$Flow_1.only$mut$fun(this);
}


first$mut(predicate_m$) {
  return base$$flows$$_TerminalOps_1.first$mut$fun(predicate_m$, this);
}


map$mut(fear2202$_m$, fear2203$_m$) {
  return base$$flows$$EmptyFlow_1.map$mut$fun(fear2202$_m$, fear2203$_m$, this);
}


map$mut(f_m$) {
  return base$$flows$$EmptyFlow_1.map$mut$fun(f_m$, this);
}


limit$mut(fear2204$_m$) {
  return base$$flows$$EmptyFlow_1.limit$mut$fun(fear2204$_m$, this);
}


any$mut(p_m$) {
  return base$$flows$$EmptyFlow_1.any$mut$fun(p_m$, this);
}


find$mut(fear2205$_m$) {
  return base$$flows$$EmptyFlow_1.find$mut$fun(fear2205$_m$, this);
}


max$mut(compare_m$) {
  return base$$flows$$_TerminalOps_1.max$mut$fun(compare_m$, this);
}


size$read() {
  return base$$flows$$EmptyFlow_1.size$read$fun(this);
}


scan$mut(acc_m$, f_m$) {
  return base$$flows$$_NonTerminalOps_1.scan$mut$fun(acc_m$, f_m$, this);
}


$hash$imm(ext_m$) {
  return base$$Extensible_1.$hash$imm$fun(ext_m$, this);
}


$hash$read(ext_m$) {
  return base$$Extensible_1.$hash$read$fun(ext_m$, this);
}


$hash$mut(ext_m$) {
  return base$$Extensible_1.$hash$mut$fun(ext_m$, this);
}


for$mut(f_m$) {
  return base$$flows$$_TerminalOps_1.for$mut$fun(f_m$, this);
}

  static filter$mut$fun(p_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static map$mut$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static map$mut$fun(fear2185$_m$, fear2186$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static flatMap$mut$fun(f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static actor$mut$fun(state_m$, f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static actorMut$mut$fun(state_m$, f_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static limit$mut$fun(fear2187$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static first$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static findMap$mut$fun(fear2188$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static find$mut$fun(fear2189$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static any$mut$fun(p_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static all$mut$fun(p_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static fold$mut$fun(acc_m$, fear2190$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static assumeFinite$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static size$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static count$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static unwrapOp$mut$fun(fear2191$_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

}
