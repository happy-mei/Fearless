import { base$$flows$$_Sink_1 } from "../../base/flows/_Sink_1.js";
import * as rt from "../rt/main.js";

export class base$$flows$$_OnePerStepSink_1 extends base$$flows$$_Sink_1 {
  static $self = new base$$flows$$_OnePerStepSink_1();

  stopDown$mut() {
  return base$$flows$$_OnePerStepSink_1.stopDown$mut$fun(this);
}


isEmpty$read() {
  return base$$flows$$_OnePerStepSink_1.isEmpty$read$fun(this);
}


pushError$mut(info_m$) {
  return base$$flows$$_OnePerStepSink_1.pushError$mut$fun(info_m$, this);
}


stepOnce$mut() {
  return base$$flows$$_OnePerStepSink_1.stepOnce$mut$fun(this);
}


$hash$mut(e_m$) {
  return base$$flows$$_OnePerStepSink_1.$hash$mut$fun(e_m$, this);
}

  static $hash$mut$fun(e_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static stopDown$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static pushError$mut$fun(info_m$, $this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static isEmpty$read$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

    static stepOnce$mut$fun($this) {
  return (function() {
  console.error("Program aborted at:\n" + new Error().stack);
  if (typeof process !== "undefined") process.exit(1);
  else throw new Error("Program aborted");
})()
;
}

}
